// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/KulaginNikita/pvz-service/internal/repository/productrepo.ProductRepository -o product_repository_mock.go -n ProductRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/KulaginNikita/pvz-service/internal/repository/productrepo/model"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// ProductRepositoryMock implements mm_productrepo.ProductRepository
type ProductRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateProduct          func(ctx context.Context, p *model.Product) (err error)
	funcCreateProductOrigin    string
	inspectFuncCreateProduct   func(ctx context.Context, p *model.Product)
	afterCreateProductCounter  uint64
	beforeCreateProductCounter uint64
	CreateProductMock          mProductRepositoryMockCreateProduct

	funcDeleteProductByID          func(ctx context.Context, productID uuid.UUID) (err error)
	funcDeleteProductByIDOrigin    string
	inspectFuncDeleteProductByID   func(ctx context.Context, productID uuid.UUID)
	afterDeleteProductByIDCounter  uint64
	beforeDeleteProductByIDCounter uint64
	DeleteProductByIDMock          mProductRepositoryMockDeleteProductByID

	funcGetLastProductIDByReceptionID          func(ctx context.Context, receptionID uuid.UUID) (u1 uuid.UUID, err error)
	funcGetLastProductIDByReceptionIDOrigin    string
	inspectFuncGetLastProductIDByReceptionID   func(ctx context.Context, receptionID uuid.UUID)
	afterGetLastProductIDByReceptionIDCounter  uint64
	beforeGetLastProductIDByReceptionIDCounter uint64
	GetLastProductIDByReceptionIDMock          mProductRepositoryMockGetLastProductIDByReceptionID

	funcGetOpenReceptionID          func(ctx context.Context, pvzID uuid.UUID) (u1 uuid.UUID, err error)
	funcGetOpenReceptionIDOrigin    string
	inspectFuncGetOpenReceptionID   func(ctx context.Context, pvzID uuid.UUID)
	afterGetOpenReceptionIDCounter  uint64
	beforeGetOpenReceptionIDCounter uint64
	GetOpenReceptionIDMock          mProductRepositoryMockGetOpenReceptionID
}

// NewProductRepositoryMock returns a mock for mm_productrepo.ProductRepository
func NewProductRepositoryMock(t minimock.Tester) *ProductRepositoryMock {
	m := &ProductRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateProductMock = mProductRepositoryMockCreateProduct{mock: m}
	m.CreateProductMock.callArgs = []*ProductRepositoryMockCreateProductParams{}

	m.DeleteProductByIDMock = mProductRepositoryMockDeleteProductByID{mock: m}
	m.DeleteProductByIDMock.callArgs = []*ProductRepositoryMockDeleteProductByIDParams{}

	m.GetLastProductIDByReceptionIDMock = mProductRepositoryMockGetLastProductIDByReceptionID{mock: m}
	m.GetLastProductIDByReceptionIDMock.callArgs = []*ProductRepositoryMockGetLastProductIDByReceptionIDParams{}

	m.GetOpenReceptionIDMock = mProductRepositoryMockGetOpenReceptionID{mock: m}
	m.GetOpenReceptionIDMock.callArgs = []*ProductRepositoryMockGetOpenReceptionIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mProductRepositoryMockCreateProduct struct {
	optional           bool
	mock               *ProductRepositoryMock
	defaultExpectation *ProductRepositoryMockCreateProductExpectation
	expectations       []*ProductRepositoryMockCreateProductExpectation

	callArgs []*ProductRepositoryMockCreateProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProductRepositoryMockCreateProductExpectation specifies expectation struct of the ProductRepository.CreateProduct
type ProductRepositoryMockCreateProductExpectation struct {
	mock               *ProductRepositoryMock
	params             *ProductRepositoryMockCreateProductParams
	paramPtrs          *ProductRepositoryMockCreateProductParamPtrs
	expectationOrigins ProductRepositoryMockCreateProductExpectationOrigins
	results            *ProductRepositoryMockCreateProductResults
	returnOrigin       string
	Counter            uint64
}

// ProductRepositoryMockCreateProductParams contains parameters of the ProductRepository.CreateProduct
type ProductRepositoryMockCreateProductParams struct {
	ctx context.Context
	p   *model.Product
}

// ProductRepositoryMockCreateProductParamPtrs contains pointers to parameters of the ProductRepository.CreateProduct
type ProductRepositoryMockCreateProductParamPtrs struct {
	ctx *context.Context
	p   **model.Product
}

// ProductRepositoryMockCreateProductResults contains results of the ProductRepository.CreateProduct
type ProductRepositoryMockCreateProductResults struct {
	err error
}

// ProductRepositoryMockCreateProductOrigins contains origins of expectations of the ProductRepository.CreateProduct
type ProductRepositoryMockCreateProductExpectationOrigins struct {
	origin    string
	originCtx string
	originP   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateProduct *mProductRepositoryMockCreateProduct) Optional() *mProductRepositoryMockCreateProduct {
	mmCreateProduct.optional = true
	return mmCreateProduct
}

// Expect sets up expected params for ProductRepository.CreateProduct
func (mmCreateProduct *mProductRepositoryMockCreateProduct) Expect(ctx context.Context, p *model.Product) *mProductRepositoryMockCreateProduct {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("ProductRepositoryMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &ProductRepositoryMockCreateProductExpectation{}
	}

	if mmCreateProduct.defaultExpectation.paramPtrs != nil {
		mmCreateProduct.mock.t.Fatalf("ProductRepositoryMock.CreateProduct mock is already set by ExpectParams functions")
	}

	mmCreateProduct.defaultExpectation.params = &ProductRepositoryMockCreateProductParams{ctx, p}
	mmCreateProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateProduct.expectations {
		if minimock.Equal(e.params, mmCreateProduct.defaultExpectation.params) {
			mmCreateProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateProduct.defaultExpectation.params)
		}
	}

	return mmCreateProduct
}

// ExpectCtxParam1 sets up expected param ctx for ProductRepository.CreateProduct
func (mmCreateProduct *mProductRepositoryMockCreateProduct) ExpectCtxParam1(ctx context.Context) *mProductRepositoryMockCreateProduct {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("ProductRepositoryMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &ProductRepositoryMockCreateProductExpectation{}
	}

	if mmCreateProduct.defaultExpectation.params != nil {
		mmCreateProduct.mock.t.Fatalf("ProductRepositoryMock.CreateProduct mock is already set by Expect")
	}

	if mmCreateProduct.defaultExpectation.paramPtrs == nil {
		mmCreateProduct.defaultExpectation.paramPtrs = &ProductRepositoryMockCreateProductParamPtrs{}
	}
	mmCreateProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateProduct
}

// ExpectPParam2 sets up expected param p for ProductRepository.CreateProduct
func (mmCreateProduct *mProductRepositoryMockCreateProduct) ExpectPParam2(p *model.Product) *mProductRepositoryMockCreateProduct {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("ProductRepositoryMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &ProductRepositoryMockCreateProductExpectation{}
	}

	if mmCreateProduct.defaultExpectation.params != nil {
		mmCreateProduct.mock.t.Fatalf("ProductRepositoryMock.CreateProduct mock is already set by Expect")
	}

	if mmCreateProduct.defaultExpectation.paramPtrs == nil {
		mmCreateProduct.defaultExpectation.paramPtrs = &ProductRepositoryMockCreateProductParamPtrs{}
	}
	mmCreateProduct.defaultExpectation.paramPtrs.p = &p
	mmCreateProduct.defaultExpectation.expectationOrigins.originP = minimock.CallerInfo(1)

	return mmCreateProduct
}

// Inspect accepts an inspector function that has same arguments as the ProductRepository.CreateProduct
func (mmCreateProduct *mProductRepositoryMockCreateProduct) Inspect(f func(ctx context.Context, p *model.Product)) *mProductRepositoryMockCreateProduct {
	if mmCreateProduct.mock.inspectFuncCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("Inspect function is already set for ProductRepositoryMock.CreateProduct")
	}

	mmCreateProduct.mock.inspectFuncCreateProduct = f

	return mmCreateProduct
}

// Return sets up results that will be returned by ProductRepository.CreateProduct
func (mmCreateProduct *mProductRepositoryMockCreateProduct) Return(err error) *ProductRepositoryMock {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("ProductRepositoryMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &ProductRepositoryMockCreateProductExpectation{mock: mmCreateProduct.mock}
	}
	mmCreateProduct.defaultExpectation.results = &ProductRepositoryMockCreateProductResults{err}
	mmCreateProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateProduct.mock
}

// Set uses given function f to mock the ProductRepository.CreateProduct method
func (mmCreateProduct *mProductRepositoryMockCreateProduct) Set(f func(ctx context.Context, p *model.Product) (err error)) *ProductRepositoryMock {
	if mmCreateProduct.defaultExpectation != nil {
		mmCreateProduct.mock.t.Fatalf("Default expectation is already set for the ProductRepository.CreateProduct method")
	}

	if len(mmCreateProduct.expectations) > 0 {
		mmCreateProduct.mock.t.Fatalf("Some expectations are already set for the ProductRepository.CreateProduct method")
	}

	mmCreateProduct.mock.funcCreateProduct = f
	mmCreateProduct.mock.funcCreateProductOrigin = minimock.CallerInfo(1)
	return mmCreateProduct.mock
}

// When sets expectation for the ProductRepository.CreateProduct which will trigger the result defined by the following
// Then helper
func (mmCreateProduct *mProductRepositoryMockCreateProduct) When(ctx context.Context, p *model.Product) *ProductRepositoryMockCreateProductExpectation {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("ProductRepositoryMock.CreateProduct mock is already set by Set")
	}

	expectation := &ProductRepositoryMockCreateProductExpectation{
		mock:               mmCreateProduct.mock,
		params:             &ProductRepositoryMockCreateProductParams{ctx, p},
		expectationOrigins: ProductRepositoryMockCreateProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateProduct.expectations = append(mmCreateProduct.expectations, expectation)
	return expectation
}

// Then sets up ProductRepository.CreateProduct return parameters for the expectation previously defined by the When method
func (e *ProductRepositoryMockCreateProductExpectation) Then(err error) *ProductRepositoryMock {
	e.results = &ProductRepositoryMockCreateProductResults{err}
	return e.mock
}

// Times sets number of times ProductRepository.CreateProduct should be invoked
func (mmCreateProduct *mProductRepositoryMockCreateProduct) Times(n uint64) *mProductRepositoryMockCreateProduct {
	if n == 0 {
		mmCreateProduct.mock.t.Fatalf("Times of ProductRepositoryMock.CreateProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateProduct.expectedInvocations, n)
	mmCreateProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateProduct
}

func (mmCreateProduct *mProductRepositoryMockCreateProduct) invocationsDone() bool {
	if len(mmCreateProduct.expectations) == 0 && mmCreateProduct.defaultExpectation == nil && mmCreateProduct.mock.funcCreateProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateProduct.mock.afterCreateProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateProduct implements mm_productrepo.ProductRepository
func (mmCreateProduct *ProductRepositoryMock) CreateProduct(ctx context.Context, p *model.Product) (err error) {
	mm_atomic.AddUint64(&mmCreateProduct.beforeCreateProductCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateProduct.afterCreateProductCounter, 1)

	mmCreateProduct.t.Helper()

	if mmCreateProduct.inspectFuncCreateProduct != nil {
		mmCreateProduct.inspectFuncCreateProduct(ctx, p)
	}

	mm_params := ProductRepositoryMockCreateProductParams{ctx, p}

	// Record call args
	mmCreateProduct.CreateProductMock.mutex.Lock()
	mmCreateProduct.CreateProductMock.callArgs = append(mmCreateProduct.CreateProductMock.callArgs, &mm_params)
	mmCreateProduct.CreateProductMock.mutex.Unlock()

	for _, e := range mmCreateProduct.CreateProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateProduct.CreateProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateProduct.CreateProductMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateProduct.CreateProductMock.defaultExpectation.params
		mm_want_ptrs := mmCreateProduct.CreateProductMock.defaultExpectation.paramPtrs

		mm_got := ProductRepositoryMockCreateProductParams{ctx, p}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateProduct.t.Errorf("ProductRepositoryMock.CreateProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProduct.CreateProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.p != nil && !minimock.Equal(*mm_want_ptrs.p, mm_got.p) {
				mmCreateProduct.t.Errorf("ProductRepositoryMock.CreateProduct got unexpected parameter p, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProduct.CreateProductMock.defaultExpectation.expectationOrigins.originP, *mm_want_ptrs.p, mm_got.p, minimock.Diff(*mm_want_ptrs.p, mm_got.p))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateProduct.t.Errorf("ProductRepositoryMock.CreateProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateProduct.CreateProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateProduct.CreateProductMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateProduct.t.Fatal("No results are set for the ProductRepositoryMock.CreateProduct")
		}
		return (*mm_results).err
	}
	if mmCreateProduct.funcCreateProduct != nil {
		return mmCreateProduct.funcCreateProduct(ctx, p)
	}
	mmCreateProduct.t.Fatalf("Unexpected call to ProductRepositoryMock.CreateProduct. %v %v", ctx, p)
	return
}

// CreateProductAfterCounter returns a count of finished ProductRepositoryMock.CreateProduct invocations
func (mmCreateProduct *ProductRepositoryMock) CreateProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProduct.afterCreateProductCounter)
}

// CreateProductBeforeCounter returns a count of ProductRepositoryMock.CreateProduct invocations
func (mmCreateProduct *ProductRepositoryMock) CreateProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProduct.beforeCreateProductCounter)
}

// Calls returns a list of arguments used in each call to ProductRepositoryMock.CreateProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateProduct *mProductRepositoryMockCreateProduct) Calls() []*ProductRepositoryMockCreateProductParams {
	mmCreateProduct.mutex.RLock()

	argCopy := make([]*ProductRepositoryMockCreateProductParams, len(mmCreateProduct.callArgs))
	copy(argCopy, mmCreateProduct.callArgs)

	mmCreateProduct.mutex.RUnlock()

	return argCopy
}

// MinimockCreateProductDone returns true if the count of the CreateProduct invocations corresponds
// the number of defined expectations
func (m *ProductRepositoryMock) MinimockCreateProductDone() bool {
	if m.CreateProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateProductMock.invocationsDone()
}

// MinimockCreateProductInspect logs each unmet expectation
func (m *ProductRepositoryMock) MinimockCreateProductInspect() {
	for _, e := range m.CreateProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductRepositoryMock.CreateProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateProductCounter := mm_atomic.LoadUint64(&m.afterCreateProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateProductMock.defaultExpectation != nil && afterCreateProductCounter < 1 {
		if m.CreateProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProductRepositoryMock.CreateProduct at\n%s", m.CreateProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProductRepositoryMock.CreateProduct at\n%s with params: %#v", m.CreateProductMock.defaultExpectation.expectationOrigins.origin, *m.CreateProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateProduct != nil && afterCreateProductCounter < 1 {
		m.t.Errorf("Expected call to ProductRepositoryMock.CreateProduct at\n%s", m.funcCreateProductOrigin)
	}

	if !m.CreateProductMock.invocationsDone() && afterCreateProductCounter > 0 {
		m.t.Errorf("Expected %d calls to ProductRepositoryMock.CreateProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateProductMock.expectedInvocations), m.CreateProductMock.expectedInvocationsOrigin, afterCreateProductCounter)
	}
}

type mProductRepositoryMockDeleteProductByID struct {
	optional           bool
	mock               *ProductRepositoryMock
	defaultExpectation *ProductRepositoryMockDeleteProductByIDExpectation
	expectations       []*ProductRepositoryMockDeleteProductByIDExpectation

	callArgs []*ProductRepositoryMockDeleteProductByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProductRepositoryMockDeleteProductByIDExpectation specifies expectation struct of the ProductRepository.DeleteProductByID
type ProductRepositoryMockDeleteProductByIDExpectation struct {
	mock               *ProductRepositoryMock
	params             *ProductRepositoryMockDeleteProductByIDParams
	paramPtrs          *ProductRepositoryMockDeleteProductByIDParamPtrs
	expectationOrigins ProductRepositoryMockDeleteProductByIDExpectationOrigins
	results            *ProductRepositoryMockDeleteProductByIDResults
	returnOrigin       string
	Counter            uint64
}

// ProductRepositoryMockDeleteProductByIDParams contains parameters of the ProductRepository.DeleteProductByID
type ProductRepositoryMockDeleteProductByIDParams struct {
	ctx       context.Context
	productID uuid.UUID
}

// ProductRepositoryMockDeleteProductByIDParamPtrs contains pointers to parameters of the ProductRepository.DeleteProductByID
type ProductRepositoryMockDeleteProductByIDParamPtrs struct {
	ctx       *context.Context
	productID *uuid.UUID
}

// ProductRepositoryMockDeleteProductByIDResults contains results of the ProductRepository.DeleteProductByID
type ProductRepositoryMockDeleteProductByIDResults struct {
	err error
}

// ProductRepositoryMockDeleteProductByIDOrigins contains origins of expectations of the ProductRepository.DeleteProductByID
type ProductRepositoryMockDeleteProductByIDExpectationOrigins struct {
	origin          string
	originCtx       string
	originProductID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteProductByID *mProductRepositoryMockDeleteProductByID) Optional() *mProductRepositoryMockDeleteProductByID {
	mmDeleteProductByID.optional = true
	return mmDeleteProductByID
}

// Expect sets up expected params for ProductRepository.DeleteProductByID
func (mmDeleteProductByID *mProductRepositoryMockDeleteProductByID) Expect(ctx context.Context, productID uuid.UUID) *mProductRepositoryMockDeleteProductByID {
	if mmDeleteProductByID.mock.funcDeleteProductByID != nil {
		mmDeleteProductByID.mock.t.Fatalf("ProductRepositoryMock.DeleteProductByID mock is already set by Set")
	}

	if mmDeleteProductByID.defaultExpectation == nil {
		mmDeleteProductByID.defaultExpectation = &ProductRepositoryMockDeleteProductByIDExpectation{}
	}

	if mmDeleteProductByID.defaultExpectation.paramPtrs != nil {
		mmDeleteProductByID.mock.t.Fatalf("ProductRepositoryMock.DeleteProductByID mock is already set by ExpectParams functions")
	}

	mmDeleteProductByID.defaultExpectation.params = &ProductRepositoryMockDeleteProductByIDParams{ctx, productID}
	mmDeleteProductByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteProductByID.expectations {
		if minimock.Equal(e.params, mmDeleteProductByID.defaultExpectation.params) {
			mmDeleteProductByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteProductByID.defaultExpectation.params)
		}
	}

	return mmDeleteProductByID
}

// ExpectCtxParam1 sets up expected param ctx for ProductRepository.DeleteProductByID
func (mmDeleteProductByID *mProductRepositoryMockDeleteProductByID) ExpectCtxParam1(ctx context.Context) *mProductRepositoryMockDeleteProductByID {
	if mmDeleteProductByID.mock.funcDeleteProductByID != nil {
		mmDeleteProductByID.mock.t.Fatalf("ProductRepositoryMock.DeleteProductByID mock is already set by Set")
	}

	if mmDeleteProductByID.defaultExpectation == nil {
		mmDeleteProductByID.defaultExpectation = &ProductRepositoryMockDeleteProductByIDExpectation{}
	}

	if mmDeleteProductByID.defaultExpectation.params != nil {
		mmDeleteProductByID.mock.t.Fatalf("ProductRepositoryMock.DeleteProductByID mock is already set by Expect")
	}

	if mmDeleteProductByID.defaultExpectation.paramPtrs == nil {
		mmDeleteProductByID.defaultExpectation.paramPtrs = &ProductRepositoryMockDeleteProductByIDParamPtrs{}
	}
	mmDeleteProductByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteProductByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteProductByID
}

// ExpectProductIDParam2 sets up expected param productID for ProductRepository.DeleteProductByID
func (mmDeleteProductByID *mProductRepositoryMockDeleteProductByID) ExpectProductIDParam2(productID uuid.UUID) *mProductRepositoryMockDeleteProductByID {
	if mmDeleteProductByID.mock.funcDeleteProductByID != nil {
		mmDeleteProductByID.mock.t.Fatalf("ProductRepositoryMock.DeleteProductByID mock is already set by Set")
	}

	if mmDeleteProductByID.defaultExpectation == nil {
		mmDeleteProductByID.defaultExpectation = &ProductRepositoryMockDeleteProductByIDExpectation{}
	}

	if mmDeleteProductByID.defaultExpectation.params != nil {
		mmDeleteProductByID.mock.t.Fatalf("ProductRepositoryMock.DeleteProductByID mock is already set by Expect")
	}

	if mmDeleteProductByID.defaultExpectation.paramPtrs == nil {
		mmDeleteProductByID.defaultExpectation.paramPtrs = &ProductRepositoryMockDeleteProductByIDParamPtrs{}
	}
	mmDeleteProductByID.defaultExpectation.paramPtrs.productID = &productID
	mmDeleteProductByID.defaultExpectation.expectationOrigins.originProductID = minimock.CallerInfo(1)

	return mmDeleteProductByID
}

// Inspect accepts an inspector function that has same arguments as the ProductRepository.DeleteProductByID
func (mmDeleteProductByID *mProductRepositoryMockDeleteProductByID) Inspect(f func(ctx context.Context, productID uuid.UUID)) *mProductRepositoryMockDeleteProductByID {
	if mmDeleteProductByID.mock.inspectFuncDeleteProductByID != nil {
		mmDeleteProductByID.mock.t.Fatalf("Inspect function is already set for ProductRepositoryMock.DeleteProductByID")
	}

	mmDeleteProductByID.mock.inspectFuncDeleteProductByID = f

	return mmDeleteProductByID
}

// Return sets up results that will be returned by ProductRepository.DeleteProductByID
func (mmDeleteProductByID *mProductRepositoryMockDeleteProductByID) Return(err error) *ProductRepositoryMock {
	if mmDeleteProductByID.mock.funcDeleteProductByID != nil {
		mmDeleteProductByID.mock.t.Fatalf("ProductRepositoryMock.DeleteProductByID mock is already set by Set")
	}

	if mmDeleteProductByID.defaultExpectation == nil {
		mmDeleteProductByID.defaultExpectation = &ProductRepositoryMockDeleteProductByIDExpectation{mock: mmDeleteProductByID.mock}
	}
	mmDeleteProductByID.defaultExpectation.results = &ProductRepositoryMockDeleteProductByIDResults{err}
	mmDeleteProductByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteProductByID.mock
}

// Set uses given function f to mock the ProductRepository.DeleteProductByID method
func (mmDeleteProductByID *mProductRepositoryMockDeleteProductByID) Set(f func(ctx context.Context, productID uuid.UUID) (err error)) *ProductRepositoryMock {
	if mmDeleteProductByID.defaultExpectation != nil {
		mmDeleteProductByID.mock.t.Fatalf("Default expectation is already set for the ProductRepository.DeleteProductByID method")
	}

	if len(mmDeleteProductByID.expectations) > 0 {
		mmDeleteProductByID.mock.t.Fatalf("Some expectations are already set for the ProductRepository.DeleteProductByID method")
	}

	mmDeleteProductByID.mock.funcDeleteProductByID = f
	mmDeleteProductByID.mock.funcDeleteProductByIDOrigin = minimock.CallerInfo(1)
	return mmDeleteProductByID.mock
}

// When sets expectation for the ProductRepository.DeleteProductByID which will trigger the result defined by the following
// Then helper
func (mmDeleteProductByID *mProductRepositoryMockDeleteProductByID) When(ctx context.Context, productID uuid.UUID) *ProductRepositoryMockDeleteProductByIDExpectation {
	if mmDeleteProductByID.mock.funcDeleteProductByID != nil {
		mmDeleteProductByID.mock.t.Fatalf("ProductRepositoryMock.DeleteProductByID mock is already set by Set")
	}

	expectation := &ProductRepositoryMockDeleteProductByIDExpectation{
		mock:               mmDeleteProductByID.mock,
		params:             &ProductRepositoryMockDeleteProductByIDParams{ctx, productID},
		expectationOrigins: ProductRepositoryMockDeleteProductByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteProductByID.expectations = append(mmDeleteProductByID.expectations, expectation)
	return expectation
}

// Then sets up ProductRepository.DeleteProductByID return parameters for the expectation previously defined by the When method
func (e *ProductRepositoryMockDeleteProductByIDExpectation) Then(err error) *ProductRepositoryMock {
	e.results = &ProductRepositoryMockDeleteProductByIDResults{err}
	return e.mock
}

// Times sets number of times ProductRepository.DeleteProductByID should be invoked
func (mmDeleteProductByID *mProductRepositoryMockDeleteProductByID) Times(n uint64) *mProductRepositoryMockDeleteProductByID {
	if n == 0 {
		mmDeleteProductByID.mock.t.Fatalf("Times of ProductRepositoryMock.DeleteProductByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteProductByID.expectedInvocations, n)
	mmDeleteProductByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteProductByID
}

func (mmDeleteProductByID *mProductRepositoryMockDeleteProductByID) invocationsDone() bool {
	if len(mmDeleteProductByID.expectations) == 0 && mmDeleteProductByID.defaultExpectation == nil && mmDeleteProductByID.mock.funcDeleteProductByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteProductByID.mock.afterDeleteProductByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteProductByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteProductByID implements mm_productrepo.ProductRepository
func (mmDeleteProductByID *ProductRepositoryMock) DeleteProductByID(ctx context.Context, productID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteProductByID.beforeDeleteProductByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteProductByID.afterDeleteProductByIDCounter, 1)

	mmDeleteProductByID.t.Helper()

	if mmDeleteProductByID.inspectFuncDeleteProductByID != nil {
		mmDeleteProductByID.inspectFuncDeleteProductByID(ctx, productID)
	}

	mm_params := ProductRepositoryMockDeleteProductByIDParams{ctx, productID}

	// Record call args
	mmDeleteProductByID.DeleteProductByIDMock.mutex.Lock()
	mmDeleteProductByID.DeleteProductByIDMock.callArgs = append(mmDeleteProductByID.DeleteProductByIDMock.callArgs, &mm_params)
	mmDeleteProductByID.DeleteProductByIDMock.mutex.Unlock()

	for _, e := range mmDeleteProductByID.DeleteProductByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteProductByID.DeleteProductByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteProductByID.DeleteProductByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteProductByID.DeleteProductByIDMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteProductByID.DeleteProductByIDMock.defaultExpectation.paramPtrs

		mm_got := ProductRepositoryMockDeleteProductByIDParams{ctx, productID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteProductByID.t.Errorf("ProductRepositoryMock.DeleteProductByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProductByID.DeleteProductByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.productID != nil && !minimock.Equal(*mm_want_ptrs.productID, mm_got.productID) {
				mmDeleteProductByID.t.Errorf("ProductRepositoryMock.DeleteProductByID got unexpected parameter productID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProductByID.DeleteProductByIDMock.defaultExpectation.expectationOrigins.originProductID, *mm_want_ptrs.productID, mm_got.productID, minimock.Diff(*mm_want_ptrs.productID, mm_got.productID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteProductByID.t.Errorf("ProductRepositoryMock.DeleteProductByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteProductByID.DeleteProductByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteProductByID.DeleteProductByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteProductByID.t.Fatal("No results are set for the ProductRepositoryMock.DeleteProductByID")
		}
		return (*mm_results).err
	}
	if mmDeleteProductByID.funcDeleteProductByID != nil {
		return mmDeleteProductByID.funcDeleteProductByID(ctx, productID)
	}
	mmDeleteProductByID.t.Fatalf("Unexpected call to ProductRepositoryMock.DeleteProductByID. %v %v", ctx, productID)
	return
}

// DeleteProductByIDAfterCounter returns a count of finished ProductRepositoryMock.DeleteProductByID invocations
func (mmDeleteProductByID *ProductRepositoryMock) DeleteProductByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProductByID.afterDeleteProductByIDCounter)
}

// DeleteProductByIDBeforeCounter returns a count of ProductRepositoryMock.DeleteProductByID invocations
func (mmDeleteProductByID *ProductRepositoryMock) DeleteProductByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProductByID.beforeDeleteProductByIDCounter)
}

// Calls returns a list of arguments used in each call to ProductRepositoryMock.DeleteProductByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteProductByID *mProductRepositoryMockDeleteProductByID) Calls() []*ProductRepositoryMockDeleteProductByIDParams {
	mmDeleteProductByID.mutex.RLock()

	argCopy := make([]*ProductRepositoryMockDeleteProductByIDParams, len(mmDeleteProductByID.callArgs))
	copy(argCopy, mmDeleteProductByID.callArgs)

	mmDeleteProductByID.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteProductByIDDone returns true if the count of the DeleteProductByID invocations corresponds
// the number of defined expectations
func (m *ProductRepositoryMock) MinimockDeleteProductByIDDone() bool {
	if m.DeleteProductByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteProductByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteProductByIDMock.invocationsDone()
}

// MinimockDeleteProductByIDInspect logs each unmet expectation
func (m *ProductRepositoryMock) MinimockDeleteProductByIDInspect() {
	for _, e := range m.DeleteProductByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductRepositoryMock.DeleteProductByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteProductByIDCounter := mm_atomic.LoadUint64(&m.afterDeleteProductByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteProductByIDMock.defaultExpectation != nil && afterDeleteProductByIDCounter < 1 {
		if m.DeleteProductByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProductRepositoryMock.DeleteProductByID at\n%s", m.DeleteProductByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProductRepositoryMock.DeleteProductByID at\n%s with params: %#v", m.DeleteProductByIDMock.defaultExpectation.expectationOrigins.origin, *m.DeleteProductByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteProductByID != nil && afterDeleteProductByIDCounter < 1 {
		m.t.Errorf("Expected call to ProductRepositoryMock.DeleteProductByID at\n%s", m.funcDeleteProductByIDOrigin)
	}

	if !m.DeleteProductByIDMock.invocationsDone() && afterDeleteProductByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ProductRepositoryMock.DeleteProductByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteProductByIDMock.expectedInvocations), m.DeleteProductByIDMock.expectedInvocationsOrigin, afterDeleteProductByIDCounter)
	}
}

type mProductRepositoryMockGetLastProductIDByReceptionID struct {
	optional           bool
	mock               *ProductRepositoryMock
	defaultExpectation *ProductRepositoryMockGetLastProductIDByReceptionIDExpectation
	expectations       []*ProductRepositoryMockGetLastProductIDByReceptionIDExpectation

	callArgs []*ProductRepositoryMockGetLastProductIDByReceptionIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProductRepositoryMockGetLastProductIDByReceptionIDExpectation specifies expectation struct of the ProductRepository.GetLastProductIDByReceptionID
type ProductRepositoryMockGetLastProductIDByReceptionIDExpectation struct {
	mock               *ProductRepositoryMock
	params             *ProductRepositoryMockGetLastProductIDByReceptionIDParams
	paramPtrs          *ProductRepositoryMockGetLastProductIDByReceptionIDParamPtrs
	expectationOrigins ProductRepositoryMockGetLastProductIDByReceptionIDExpectationOrigins
	results            *ProductRepositoryMockGetLastProductIDByReceptionIDResults
	returnOrigin       string
	Counter            uint64
}

// ProductRepositoryMockGetLastProductIDByReceptionIDParams contains parameters of the ProductRepository.GetLastProductIDByReceptionID
type ProductRepositoryMockGetLastProductIDByReceptionIDParams struct {
	ctx         context.Context
	receptionID uuid.UUID
}

// ProductRepositoryMockGetLastProductIDByReceptionIDParamPtrs contains pointers to parameters of the ProductRepository.GetLastProductIDByReceptionID
type ProductRepositoryMockGetLastProductIDByReceptionIDParamPtrs struct {
	ctx         *context.Context
	receptionID *uuid.UUID
}

// ProductRepositoryMockGetLastProductIDByReceptionIDResults contains results of the ProductRepository.GetLastProductIDByReceptionID
type ProductRepositoryMockGetLastProductIDByReceptionIDResults struct {
	u1  uuid.UUID
	err error
}

// ProductRepositoryMockGetLastProductIDByReceptionIDOrigins contains origins of expectations of the ProductRepository.GetLastProductIDByReceptionID
type ProductRepositoryMockGetLastProductIDByReceptionIDExpectationOrigins struct {
	origin            string
	originCtx         string
	originReceptionID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLastProductIDByReceptionID *mProductRepositoryMockGetLastProductIDByReceptionID) Optional() *mProductRepositoryMockGetLastProductIDByReceptionID {
	mmGetLastProductIDByReceptionID.optional = true
	return mmGetLastProductIDByReceptionID
}

// Expect sets up expected params for ProductRepository.GetLastProductIDByReceptionID
func (mmGetLastProductIDByReceptionID *mProductRepositoryMockGetLastProductIDByReceptionID) Expect(ctx context.Context, receptionID uuid.UUID) *mProductRepositoryMockGetLastProductIDByReceptionID {
	if mmGetLastProductIDByReceptionID.mock.funcGetLastProductIDByReceptionID != nil {
		mmGetLastProductIDByReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetLastProductIDByReceptionID mock is already set by Set")
	}

	if mmGetLastProductIDByReceptionID.defaultExpectation == nil {
		mmGetLastProductIDByReceptionID.defaultExpectation = &ProductRepositoryMockGetLastProductIDByReceptionIDExpectation{}
	}

	if mmGetLastProductIDByReceptionID.defaultExpectation.paramPtrs != nil {
		mmGetLastProductIDByReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetLastProductIDByReceptionID mock is already set by ExpectParams functions")
	}

	mmGetLastProductIDByReceptionID.defaultExpectation.params = &ProductRepositoryMockGetLastProductIDByReceptionIDParams{ctx, receptionID}
	mmGetLastProductIDByReceptionID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetLastProductIDByReceptionID.expectations {
		if minimock.Equal(e.params, mmGetLastProductIDByReceptionID.defaultExpectation.params) {
			mmGetLastProductIDByReceptionID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLastProductIDByReceptionID.defaultExpectation.params)
		}
	}

	return mmGetLastProductIDByReceptionID
}

// ExpectCtxParam1 sets up expected param ctx for ProductRepository.GetLastProductIDByReceptionID
func (mmGetLastProductIDByReceptionID *mProductRepositoryMockGetLastProductIDByReceptionID) ExpectCtxParam1(ctx context.Context) *mProductRepositoryMockGetLastProductIDByReceptionID {
	if mmGetLastProductIDByReceptionID.mock.funcGetLastProductIDByReceptionID != nil {
		mmGetLastProductIDByReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetLastProductIDByReceptionID mock is already set by Set")
	}

	if mmGetLastProductIDByReceptionID.defaultExpectation == nil {
		mmGetLastProductIDByReceptionID.defaultExpectation = &ProductRepositoryMockGetLastProductIDByReceptionIDExpectation{}
	}

	if mmGetLastProductIDByReceptionID.defaultExpectation.params != nil {
		mmGetLastProductIDByReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetLastProductIDByReceptionID mock is already set by Expect")
	}

	if mmGetLastProductIDByReceptionID.defaultExpectation.paramPtrs == nil {
		mmGetLastProductIDByReceptionID.defaultExpectation.paramPtrs = &ProductRepositoryMockGetLastProductIDByReceptionIDParamPtrs{}
	}
	mmGetLastProductIDByReceptionID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetLastProductIDByReceptionID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetLastProductIDByReceptionID
}

// ExpectReceptionIDParam2 sets up expected param receptionID for ProductRepository.GetLastProductIDByReceptionID
func (mmGetLastProductIDByReceptionID *mProductRepositoryMockGetLastProductIDByReceptionID) ExpectReceptionIDParam2(receptionID uuid.UUID) *mProductRepositoryMockGetLastProductIDByReceptionID {
	if mmGetLastProductIDByReceptionID.mock.funcGetLastProductIDByReceptionID != nil {
		mmGetLastProductIDByReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetLastProductIDByReceptionID mock is already set by Set")
	}

	if mmGetLastProductIDByReceptionID.defaultExpectation == nil {
		mmGetLastProductIDByReceptionID.defaultExpectation = &ProductRepositoryMockGetLastProductIDByReceptionIDExpectation{}
	}

	if mmGetLastProductIDByReceptionID.defaultExpectation.params != nil {
		mmGetLastProductIDByReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetLastProductIDByReceptionID mock is already set by Expect")
	}

	if mmGetLastProductIDByReceptionID.defaultExpectation.paramPtrs == nil {
		mmGetLastProductIDByReceptionID.defaultExpectation.paramPtrs = &ProductRepositoryMockGetLastProductIDByReceptionIDParamPtrs{}
	}
	mmGetLastProductIDByReceptionID.defaultExpectation.paramPtrs.receptionID = &receptionID
	mmGetLastProductIDByReceptionID.defaultExpectation.expectationOrigins.originReceptionID = minimock.CallerInfo(1)

	return mmGetLastProductIDByReceptionID
}

// Inspect accepts an inspector function that has same arguments as the ProductRepository.GetLastProductIDByReceptionID
func (mmGetLastProductIDByReceptionID *mProductRepositoryMockGetLastProductIDByReceptionID) Inspect(f func(ctx context.Context, receptionID uuid.UUID)) *mProductRepositoryMockGetLastProductIDByReceptionID {
	if mmGetLastProductIDByReceptionID.mock.inspectFuncGetLastProductIDByReceptionID != nil {
		mmGetLastProductIDByReceptionID.mock.t.Fatalf("Inspect function is already set for ProductRepositoryMock.GetLastProductIDByReceptionID")
	}

	mmGetLastProductIDByReceptionID.mock.inspectFuncGetLastProductIDByReceptionID = f

	return mmGetLastProductIDByReceptionID
}

// Return sets up results that will be returned by ProductRepository.GetLastProductIDByReceptionID
func (mmGetLastProductIDByReceptionID *mProductRepositoryMockGetLastProductIDByReceptionID) Return(u1 uuid.UUID, err error) *ProductRepositoryMock {
	if mmGetLastProductIDByReceptionID.mock.funcGetLastProductIDByReceptionID != nil {
		mmGetLastProductIDByReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetLastProductIDByReceptionID mock is already set by Set")
	}

	if mmGetLastProductIDByReceptionID.defaultExpectation == nil {
		mmGetLastProductIDByReceptionID.defaultExpectation = &ProductRepositoryMockGetLastProductIDByReceptionIDExpectation{mock: mmGetLastProductIDByReceptionID.mock}
	}
	mmGetLastProductIDByReceptionID.defaultExpectation.results = &ProductRepositoryMockGetLastProductIDByReceptionIDResults{u1, err}
	mmGetLastProductIDByReceptionID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetLastProductIDByReceptionID.mock
}

// Set uses given function f to mock the ProductRepository.GetLastProductIDByReceptionID method
func (mmGetLastProductIDByReceptionID *mProductRepositoryMockGetLastProductIDByReceptionID) Set(f func(ctx context.Context, receptionID uuid.UUID) (u1 uuid.UUID, err error)) *ProductRepositoryMock {
	if mmGetLastProductIDByReceptionID.defaultExpectation != nil {
		mmGetLastProductIDByReceptionID.mock.t.Fatalf("Default expectation is already set for the ProductRepository.GetLastProductIDByReceptionID method")
	}

	if len(mmGetLastProductIDByReceptionID.expectations) > 0 {
		mmGetLastProductIDByReceptionID.mock.t.Fatalf("Some expectations are already set for the ProductRepository.GetLastProductIDByReceptionID method")
	}

	mmGetLastProductIDByReceptionID.mock.funcGetLastProductIDByReceptionID = f
	mmGetLastProductIDByReceptionID.mock.funcGetLastProductIDByReceptionIDOrigin = minimock.CallerInfo(1)
	return mmGetLastProductIDByReceptionID.mock
}

// When sets expectation for the ProductRepository.GetLastProductIDByReceptionID which will trigger the result defined by the following
// Then helper
func (mmGetLastProductIDByReceptionID *mProductRepositoryMockGetLastProductIDByReceptionID) When(ctx context.Context, receptionID uuid.UUID) *ProductRepositoryMockGetLastProductIDByReceptionIDExpectation {
	if mmGetLastProductIDByReceptionID.mock.funcGetLastProductIDByReceptionID != nil {
		mmGetLastProductIDByReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetLastProductIDByReceptionID mock is already set by Set")
	}

	expectation := &ProductRepositoryMockGetLastProductIDByReceptionIDExpectation{
		mock:               mmGetLastProductIDByReceptionID.mock,
		params:             &ProductRepositoryMockGetLastProductIDByReceptionIDParams{ctx, receptionID},
		expectationOrigins: ProductRepositoryMockGetLastProductIDByReceptionIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetLastProductIDByReceptionID.expectations = append(mmGetLastProductIDByReceptionID.expectations, expectation)
	return expectation
}

// Then sets up ProductRepository.GetLastProductIDByReceptionID return parameters for the expectation previously defined by the When method
func (e *ProductRepositoryMockGetLastProductIDByReceptionIDExpectation) Then(u1 uuid.UUID, err error) *ProductRepositoryMock {
	e.results = &ProductRepositoryMockGetLastProductIDByReceptionIDResults{u1, err}
	return e.mock
}

// Times sets number of times ProductRepository.GetLastProductIDByReceptionID should be invoked
func (mmGetLastProductIDByReceptionID *mProductRepositoryMockGetLastProductIDByReceptionID) Times(n uint64) *mProductRepositoryMockGetLastProductIDByReceptionID {
	if n == 0 {
		mmGetLastProductIDByReceptionID.mock.t.Fatalf("Times of ProductRepositoryMock.GetLastProductIDByReceptionID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLastProductIDByReceptionID.expectedInvocations, n)
	mmGetLastProductIDByReceptionID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetLastProductIDByReceptionID
}

func (mmGetLastProductIDByReceptionID *mProductRepositoryMockGetLastProductIDByReceptionID) invocationsDone() bool {
	if len(mmGetLastProductIDByReceptionID.expectations) == 0 && mmGetLastProductIDByReceptionID.defaultExpectation == nil && mmGetLastProductIDByReceptionID.mock.funcGetLastProductIDByReceptionID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLastProductIDByReceptionID.mock.afterGetLastProductIDByReceptionIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLastProductIDByReceptionID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLastProductIDByReceptionID implements mm_productrepo.ProductRepository
func (mmGetLastProductIDByReceptionID *ProductRepositoryMock) GetLastProductIDByReceptionID(ctx context.Context, receptionID uuid.UUID) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmGetLastProductIDByReceptionID.beforeGetLastProductIDByReceptionIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLastProductIDByReceptionID.afterGetLastProductIDByReceptionIDCounter, 1)

	mmGetLastProductIDByReceptionID.t.Helper()

	if mmGetLastProductIDByReceptionID.inspectFuncGetLastProductIDByReceptionID != nil {
		mmGetLastProductIDByReceptionID.inspectFuncGetLastProductIDByReceptionID(ctx, receptionID)
	}

	mm_params := ProductRepositoryMockGetLastProductIDByReceptionIDParams{ctx, receptionID}

	// Record call args
	mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.mutex.Lock()
	mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.callArgs = append(mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.callArgs, &mm_params)
	mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.mutex.Unlock()

	for _, e := range mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.defaultExpectation.paramPtrs

		mm_got := ProductRepositoryMockGetLastProductIDByReceptionIDParams{ctx, receptionID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLastProductIDByReceptionID.t.Errorf("ProductRepositoryMock.GetLastProductIDByReceptionID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.receptionID != nil && !minimock.Equal(*mm_want_ptrs.receptionID, mm_got.receptionID) {
				mmGetLastProductIDByReceptionID.t.Errorf("ProductRepositoryMock.GetLastProductIDByReceptionID got unexpected parameter receptionID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.defaultExpectation.expectationOrigins.originReceptionID, *mm_want_ptrs.receptionID, mm_got.receptionID, minimock.Diff(*mm_want_ptrs.receptionID, mm_got.receptionID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLastProductIDByReceptionID.t.Errorf("ProductRepositoryMock.GetLastProductIDByReceptionID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLastProductIDByReceptionID.GetLastProductIDByReceptionIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLastProductIDByReceptionID.t.Fatal("No results are set for the ProductRepositoryMock.GetLastProductIDByReceptionID")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetLastProductIDByReceptionID.funcGetLastProductIDByReceptionID != nil {
		return mmGetLastProductIDByReceptionID.funcGetLastProductIDByReceptionID(ctx, receptionID)
	}
	mmGetLastProductIDByReceptionID.t.Fatalf("Unexpected call to ProductRepositoryMock.GetLastProductIDByReceptionID. %v %v", ctx, receptionID)
	return
}

// GetLastProductIDByReceptionIDAfterCounter returns a count of finished ProductRepositoryMock.GetLastProductIDByReceptionID invocations
func (mmGetLastProductIDByReceptionID *ProductRepositoryMock) GetLastProductIDByReceptionIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLastProductIDByReceptionID.afterGetLastProductIDByReceptionIDCounter)
}

// GetLastProductIDByReceptionIDBeforeCounter returns a count of ProductRepositoryMock.GetLastProductIDByReceptionID invocations
func (mmGetLastProductIDByReceptionID *ProductRepositoryMock) GetLastProductIDByReceptionIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLastProductIDByReceptionID.beforeGetLastProductIDByReceptionIDCounter)
}

// Calls returns a list of arguments used in each call to ProductRepositoryMock.GetLastProductIDByReceptionID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLastProductIDByReceptionID *mProductRepositoryMockGetLastProductIDByReceptionID) Calls() []*ProductRepositoryMockGetLastProductIDByReceptionIDParams {
	mmGetLastProductIDByReceptionID.mutex.RLock()

	argCopy := make([]*ProductRepositoryMockGetLastProductIDByReceptionIDParams, len(mmGetLastProductIDByReceptionID.callArgs))
	copy(argCopy, mmGetLastProductIDByReceptionID.callArgs)

	mmGetLastProductIDByReceptionID.mutex.RUnlock()

	return argCopy
}

// MinimockGetLastProductIDByReceptionIDDone returns true if the count of the GetLastProductIDByReceptionID invocations corresponds
// the number of defined expectations
func (m *ProductRepositoryMock) MinimockGetLastProductIDByReceptionIDDone() bool {
	if m.GetLastProductIDByReceptionIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLastProductIDByReceptionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLastProductIDByReceptionIDMock.invocationsDone()
}

// MinimockGetLastProductIDByReceptionIDInspect logs each unmet expectation
func (m *ProductRepositoryMock) MinimockGetLastProductIDByReceptionIDInspect() {
	for _, e := range m.GetLastProductIDByReceptionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductRepositoryMock.GetLastProductIDByReceptionID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetLastProductIDByReceptionIDCounter := mm_atomic.LoadUint64(&m.afterGetLastProductIDByReceptionIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLastProductIDByReceptionIDMock.defaultExpectation != nil && afterGetLastProductIDByReceptionIDCounter < 1 {
		if m.GetLastProductIDByReceptionIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProductRepositoryMock.GetLastProductIDByReceptionID at\n%s", m.GetLastProductIDByReceptionIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProductRepositoryMock.GetLastProductIDByReceptionID at\n%s with params: %#v", m.GetLastProductIDByReceptionIDMock.defaultExpectation.expectationOrigins.origin, *m.GetLastProductIDByReceptionIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLastProductIDByReceptionID != nil && afterGetLastProductIDByReceptionIDCounter < 1 {
		m.t.Errorf("Expected call to ProductRepositoryMock.GetLastProductIDByReceptionID at\n%s", m.funcGetLastProductIDByReceptionIDOrigin)
	}

	if !m.GetLastProductIDByReceptionIDMock.invocationsDone() && afterGetLastProductIDByReceptionIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ProductRepositoryMock.GetLastProductIDByReceptionID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetLastProductIDByReceptionIDMock.expectedInvocations), m.GetLastProductIDByReceptionIDMock.expectedInvocationsOrigin, afterGetLastProductIDByReceptionIDCounter)
	}
}

type mProductRepositoryMockGetOpenReceptionID struct {
	optional           bool
	mock               *ProductRepositoryMock
	defaultExpectation *ProductRepositoryMockGetOpenReceptionIDExpectation
	expectations       []*ProductRepositoryMockGetOpenReceptionIDExpectation

	callArgs []*ProductRepositoryMockGetOpenReceptionIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProductRepositoryMockGetOpenReceptionIDExpectation specifies expectation struct of the ProductRepository.GetOpenReceptionID
type ProductRepositoryMockGetOpenReceptionIDExpectation struct {
	mock               *ProductRepositoryMock
	params             *ProductRepositoryMockGetOpenReceptionIDParams
	paramPtrs          *ProductRepositoryMockGetOpenReceptionIDParamPtrs
	expectationOrigins ProductRepositoryMockGetOpenReceptionIDExpectationOrigins
	results            *ProductRepositoryMockGetOpenReceptionIDResults
	returnOrigin       string
	Counter            uint64
}

// ProductRepositoryMockGetOpenReceptionIDParams contains parameters of the ProductRepository.GetOpenReceptionID
type ProductRepositoryMockGetOpenReceptionIDParams struct {
	ctx   context.Context
	pvzID uuid.UUID
}

// ProductRepositoryMockGetOpenReceptionIDParamPtrs contains pointers to parameters of the ProductRepository.GetOpenReceptionID
type ProductRepositoryMockGetOpenReceptionIDParamPtrs struct {
	ctx   *context.Context
	pvzID *uuid.UUID
}

// ProductRepositoryMockGetOpenReceptionIDResults contains results of the ProductRepository.GetOpenReceptionID
type ProductRepositoryMockGetOpenReceptionIDResults struct {
	u1  uuid.UUID
	err error
}

// ProductRepositoryMockGetOpenReceptionIDOrigins contains origins of expectations of the ProductRepository.GetOpenReceptionID
type ProductRepositoryMockGetOpenReceptionIDExpectationOrigins struct {
	origin      string
	originCtx   string
	originPvzID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOpenReceptionID *mProductRepositoryMockGetOpenReceptionID) Optional() *mProductRepositoryMockGetOpenReceptionID {
	mmGetOpenReceptionID.optional = true
	return mmGetOpenReceptionID
}

// Expect sets up expected params for ProductRepository.GetOpenReceptionID
func (mmGetOpenReceptionID *mProductRepositoryMockGetOpenReceptionID) Expect(ctx context.Context, pvzID uuid.UUID) *mProductRepositoryMockGetOpenReceptionID {
	if mmGetOpenReceptionID.mock.funcGetOpenReceptionID != nil {
		mmGetOpenReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetOpenReceptionID mock is already set by Set")
	}

	if mmGetOpenReceptionID.defaultExpectation == nil {
		mmGetOpenReceptionID.defaultExpectation = &ProductRepositoryMockGetOpenReceptionIDExpectation{}
	}

	if mmGetOpenReceptionID.defaultExpectation.paramPtrs != nil {
		mmGetOpenReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetOpenReceptionID mock is already set by ExpectParams functions")
	}

	mmGetOpenReceptionID.defaultExpectation.params = &ProductRepositoryMockGetOpenReceptionIDParams{ctx, pvzID}
	mmGetOpenReceptionID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOpenReceptionID.expectations {
		if minimock.Equal(e.params, mmGetOpenReceptionID.defaultExpectation.params) {
			mmGetOpenReceptionID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOpenReceptionID.defaultExpectation.params)
		}
	}

	return mmGetOpenReceptionID
}

// ExpectCtxParam1 sets up expected param ctx for ProductRepository.GetOpenReceptionID
func (mmGetOpenReceptionID *mProductRepositoryMockGetOpenReceptionID) ExpectCtxParam1(ctx context.Context) *mProductRepositoryMockGetOpenReceptionID {
	if mmGetOpenReceptionID.mock.funcGetOpenReceptionID != nil {
		mmGetOpenReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetOpenReceptionID mock is already set by Set")
	}

	if mmGetOpenReceptionID.defaultExpectation == nil {
		mmGetOpenReceptionID.defaultExpectation = &ProductRepositoryMockGetOpenReceptionIDExpectation{}
	}

	if mmGetOpenReceptionID.defaultExpectation.params != nil {
		mmGetOpenReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetOpenReceptionID mock is already set by Expect")
	}

	if mmGetOpenReceptionID.defaultExpectation.paramPtrs == nil {
		mmGetOpenReceptionID.defaultExpectation.paramPtrs = &ProductRepositoryMockGetOpenReceptionIDParamPtrs{}
	}
	mmGetOpenReceptionID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetOpenReceptionID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetOpenReceptionID
}

// ExpectPvzIDParam2 sets up expected param pvzID for ProductRepository.GetOpenReceptionID
func (mmGetOpenReceptionID *mProductRepositoryMockGetOpenReceptionID) ExpectPvzIDParam2(pvzID uuid.UUID) *mProductRepositoryMockGetOpenReceptionID {
	if mmGetOpenReceptionID.mock.funcGetOpenReceptionID != nil {
		mmGetOpenReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetOpenReceptionID mock is already set by Set")
	}

	if mmGetOpenReceptionID.defaultExpectation == nil {
		mmGetOpenReceptionID.defaultExpectation = &ProductRepositoryMockGetOpenReceptionIDExpectation{}
	}

	if mmGetOpenReceptionID.defaultExpectation.params != nil {
		mmGetOpenReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetOpenReceptionID mock is already set by Expect")
	}

	if mmGetOpenReceptionID.defaultExpectation.paramPtrs == nil {
		mmGetOpenReceptionID.defaultExpectation.paramPtrs = &ProductRepositoryMockGetOpenReceptionIDParamPtrs{}
	}
	mmGetOpenReceptionID.defaultExpectation.paramPtrs.pvzID = &pvzID
	mmGetOpenReceptionID.defaultExpectation.expectationOrigins.originPvzID = minimock.CallerInfo(1)

	return mmGetOpenReceptionID
}

// Inspect accepts an inspector function that has same arguments as the ProductRepository.GetOpenReceptionID
func (mmGetOpenReceptionID *mProductRepositoryMockGetOpenReceptionID) Inspect(f func(ctx context.Context, pvzID uuid.UUID)) *mProductRepositoryMockGetOpenReceptionID {
	if mmGetOpenReceptionID.mock.inspectFuncGetOpenReceptionID != nil {
		mmGetOpenReceptionID.mock.t.Fatalf("Inspect function is already set for ProductRepositoryMock.GetOpenReceptionID")
	}

	mmGetOpenReceptionID.mock.inspectFuncGetOpenReceptionID = f

	return mmGetOpenReceptionID
}

// Return sets up results that will be returned by ProductRepository.GetOpenReceptionID
func (mmGetOpenReceptionID *mProductRepositoryMockGetOpenReceptionID) Return(u1 uuid.UUID, err error) *ProductRepositoryMock {
	if mmGetOpenReceptionID.mock.funcGetOpenReceptionID != nil {
		mmGetOpenReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetOpenReceptionID mock is already set by Set")
	}

	if mmGetOpenReceptionID.defaultExpectation == nil {
		mmGetOpenReceptionID.defaultExpectation = &ProductRepositoryMockGetOpenReceptionIDExpectation{mock: mmGetOpenReceptionID.mock}
	}
	mmGetOpenReceptionID.defaultExpectation.results = &ProductRepositoryMockGetOpenReceptionIDResults{u1, err}
	mmGetOpenReceptionID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOpenReceptionID.mock
}

// Set uses given function f to mock the ProductRepository.GetOpenReceptionID method
func (mmGetOpenReceptionID *mProductRepositoryMockGetOpenReceptionID) Set(f func(ctx context.Context, pvzID uuid.UUID) (u1 uuid.UUID, err error)) *ProductRepositoryMock {
	if mmGetOpenReceptionID.defaultExpectation != nil {
		mmGetOpenReceptionID.mock.t.Fatalf("Default expectation is already set for the ProductRepository.GetOpenReceptionID method")
	}

	if len(mmGetOpenReceptionID.expectations) > 0 {
		mmGetOpenReceptionID.mock.t.Fatalf("Some expectations are already set for the ProductRepository.GetOpenReceptionID method")
	}

	mmGetOpenReceptionID.mock.funcGetOpenReceptionID = f
	mmGetOpenReceptionID.mock.funcGetOpenReceptionIDOrigin = minimock.CallerInfo(1)
	return mmGetOpenReceptionID.mock
}

// When sets expectation for the ProductRepository.GetOpenReceptionID which will trigger the result defined by the following
// Then helper
func (mmGetOpenReceptionID *mProductRepositoryMockGetOpenReceptionID) When(ctx context.Context, pvzID uuid.UUID) *ProductRepositoryMockGetOpenReceptionIDExpectation {
	if mmGetOpenReceptionID.mock.funcGetOpenReceptionID != nil {
		mmGetOpenReceptionID.mock.t.Fatalf("ProductRepositoryMock.GetOpenReceptionID mock is already set by Set")
	}

	expectation := &ProductRepositoryMockGetOpenReceptionIDExpectation{
		mock:               mmGetOpenReceptionID.mock,
		params:             &ProductRepositoryMockGetOpenReceptionIDParams{ctx, pvzID},
		expectationOrigins: ProductRepositoryMockGetOpenReceptionIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOpenReceptionID.expectations = append(mmGetOpenReceptionID.expectations, expectation)
	return expectation
}

// Then sets up ProductRepository.GetOpenReceptionID return parameters for the expectation previously defined by the When method
func (e *ProductRepositoryMockGetOpenReceptionIDExpectation) Then(u1 uuid.UUID, err error) *ProductRepositoryMock {
	e.results = &ProductRepositoryMockGetOpenReceptionIDResults{u1, err}
	return e.mock
}

// Times sets number of times ProductRepository.GetOpenReceptionID should be invoked
func (mmGetOpenReceptionID *mProductRepositoryMockGetOpenReceptionID) Times(n uint64) *mProductRepositoryMockGetOpenReceptionID {
	if n == 0 {
		mmGetOpenReceptionID.mock.t.Fatalf("Times of ProductRepositoryMock.GetOpenReceptionID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOpenReceptionID.expectedInvocations, n)
	mmGetOpenReceptionID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOpenReceptionID
}

func (mmGetOpenReceptionID *mProductRepositoryMockGetOpenReceptionID) invocationsDone() bool {
	if len(mmGetOpenReceptionID.expectations) == 0 && mmGetOpenReceptionID.defaultExpectation == nil && mmGetOpenReceptionID.mock.funcGetOpenReceptionID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOpenReceptionID.mock.afterGetOpenReceptionIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOpenReceptionID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOpenReceptionID implements mm_productrepo.ProductRepository
func (mmGetOpenReceptionID *ProductRepositoryMock) GetOpenReceptionID(ctx context.Context, pvzID uuid.UUID) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmGetOpenReceptionID.beforeGetOpenReceptionIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOpenReceptionID.afterGetOpenReceptionIDCounter, 1)

	mmGetOpenReceptionID.t.Helper()

	if mmGetOpenReceptionID.inspectFuncGetOpenReceptionID != nil {
		mmGetOpenReceptionID.inspectFuncGetOpenReceptionID(ctx, pvzID)
	}

	mm_params := ProductRepositoryMockGetOpenReceptionIDParams{ctx, pvzID}

	// Record call args
	mmGetOpenReceptionID.GetOpenReceptionIDMock.mutex.Lock()
	mmGetOpenReceptionID.GetOpenReceptionIDMock.callArgs = append(mmGetOpenReceptionID.GetOpenReceptionIDMock.callArgs, &mm_params)
	mmGetOpenReceptionID.GetOpenReceptionIDMock.mutex.Unlock()

	for _, e := range mmGetOpenReceptionID.GetOpenReceptionIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmGetOpenReceptionID.GetOpenReceptionIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOpenReceptionID.GetOpenReceptionIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOpenReceptionID.GetOpenReceptionIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetOpenReceptionID.GetOpenReceptionIDMock.defaultExpectation.paramPtrs

		mm_got := ProductRepositoryMockGetOpenReceptionIDParams{ctx, pvzID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetOpenReceptionID.t.Errorf("ProductRepositoryMock.GetOpenReceptionID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOpenReceptionID.GetOpenReceptionIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvzID != nil && !minimock.Equal(*mm_want_ptrs.pvzID, mm_got.pvzID) {
				mmGetOpenReceptionID.t.Errorf("ProductRepositoryMock.GetOpenReceptionID got unexpected parameter pvzID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOpenReceptionID.GetOpenReceptionIDMock.defaultExpectation.expectationOrigins.originPvzID, *mm_want_ptrs.pvzID, mm_got.pvzID, minimock.Diff(*mm_want_ptrs.pvzID, mm_got.pvzID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOpenReceptionID.t.Errorf("ProductRepositoryMock.GetOpenReceptionID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOpenReceptionID.GetOpenReceptionIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOpenReceptionID.GetOpenReceptionIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOpenReceptionID.t.Fatal("No results are set for the ProductRepositoryMock.GetOpenReceptionID")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmGetOpenReceptionID.funcGetOpenReceptionID != nil {
		return mmGetOpenReceptionID.funcGetOpenReceptionID(ctx, pvzID)
	}
	mmGetOpenReceptionID.t.Fatalf("Unexpected call to ProductRepositoryMock.GetOpenReceptionID. %v %v", ctx, pvzID)
	return
}

// GetOpenReceptionIDAfterCounter returns a count of finished ProductRepositoryMock.GetOpenReceptionID invocations
func (mmGetOpenReceptionID *ProductRepositoryMock) GetOpenReceptionIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOpenReceptionID.afterGetOpenReceptionIDCounter)
}

// GetOpenReceptionIDBeforeCounter returns a count of ProductRepositoryMock.GetOpenReceptionID invocations
func (mmGetOpenReceptionID *ProductRepositoryMock) GetOpenReceptionIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOpenReceptionID.beforeGetOpenReceptionIDCounter)
}

// Calls returns a list of arguments used in each call to ProductRepositoryMock.GetOpenReceptionID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOpenReceptionID *mProductRepositoryMockGetOpenReceptionID) Calls() []*ProductRepositoryMockGetOpenReceptionIDParams {
	mmGetOpenReceptionID.mutex.RLock()

	argCopy := make([]*ProductRepositoryMockGetOpenReceptionIDParams, len(mmGetOpenReceptionID.callArgs))
	copy(argCopy, mmGetOpenReceptionID.callArgs)

	mmGetOpenReceptionID.mutex.RUnlock()

	return argCopy
}

// MinimockGetOpenReceptionIDDone returns true if the count of the GetOpenReceptionID invocations corresponds
// the number of defined expectations
func (m *ProductRepositoryMock) MinimockGetOpenReceptionIDDone() bool {
	if m.GetOpenReceptionIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOpenReceptionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOpenReceptionIDMock.invocationsDone()
}

// MinimockGetOpenReceptionIDInspect logs each unmet expectation
func (m *ProductRepositoryMock) MinimockGetOpenReceptionIDInspect() {
	for _, e := range m.GetOpenReceptionIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductRepositoryMock.GetOpenReceptionID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOpenReceptionIDCounter := mm_atomic.LoadUint64(&m.afterGetOpenReceptionIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOpenReceptionIDMock.defaultExpectation != nil && afterGetOpenReceptionIDCounter < 1 {
		if m.GetOpenReceptionIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProductRepositoryMock.GetOpenReceptionID at\n%s", m.GetOpenReceptionIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProductRepositoryMock.GetOpenReceptionID at\n%s with params: %#v", m.GetOpenReceptionIDMock.defaultExpectation.expectationOrigins.origin, *m.GetOpenReceptionIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOpenReceptionID != nil && afterGetOpenReceptionIDCounter < 1 {
		m.t.Errorf("Expected call to ProductRepositoryMock.GetOpenReceptionID at\n%s", m.funcGetOpenReceptionIDOrigin)
	}

	if !m.GetOpenReceptionIDMock.invocationsDone() && afterGetOpenReceptionIDCounter > 0 {
		m.t.Errorf("Expected %d calls to ProductRepositoryMock.GetOpenReceptionID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOpenReceptionIDMock.expectedInvocations), m.GetOpenReceptionIDMock.expectedInvocationsOrigin, afterGetOpenReceptionIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProductRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateProductInspect()

			m.MinimockDeleteProductByIDInspect()

			m.MinimockGetLastProductIDByReceptionIDInspect()

			m.MinimockGetOpenReceptionIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProductRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProductRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateProductDone() &&
		m.MinimockDeleteProductByIDDone() &&
		m.MinimockGetLastProductIDByReceptionIDDone() &&
		m.MinimockGetOpenReceptionIDDone()
}
