// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/KulaginNikita/pvz-service/internal/repository/pvzrepo.PVZRepository -o pvz_repository_mock.go -n PVZRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/KulaginNikita/pvz-service/internal/domain/pvz"
	"github.com/KulaginNikita/pvz-service/internal/repository/pvzrepo/model"
	"github.com/gojuno/minimock/v3"
)

// PVZRepositoryMock implements mm_pvzrepo.PVZRepository
type PVZRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreatePVZ          func(ctx context.Context, p *model.PVZ) (err error)
	funcCreatePVZOrigin    string
	inspectFuncCreatePVZ   func(ctx context.Context, p *model.PVZ)
	afterCreatePVZCounter  uint64
	beforeCreatePVZCounter uint64
	CreatePVZMock          mPVZRepositoryMockCreatePVZ

	funcGetPVZ          func(ctx context.Context, params *pvz.PVZFilter) (pa1 []pvz.PVZ, err error)
	funcGetPVZOrigin    string
	inspectFuncGetPVZ   func(ctx context.Context, params *pvz.PVZFilter)
	afterGetPVZCounter  uint64
	beforeGetPVZCounter uint64
	GetPVZMock          mPVZRepositoryMockGetPVZ
}

// NewPVZRepositoryMock returns a mock for mm_pvzrepo.PVZRepository
func NewPVZRepositoryMock(t minimock.Tester) *PVZRepositoryMock {
	m := &PVZRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreatePVZMock = mPVZRepositoryMockCreatePVZ{mock: m}
	m.CreatePVZMock.callArgs = []*PVZRepositoryMockCreatePVZParams{}

	m.GetPVZMock = mPVZRepositoryMockGetPVZ{mock: m}
	m.GetPVZMock.callArgs = []*PVZRepositoryMockGetPVZParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPVZRepositoryMockCreatePVZ struct {
	optional           bool
	mock               *PVZRepositoryMock
	defaultExpectation *PVZRepositoryMockCreatePVZExpectation
	expectations       []*PVZRepositoryMockCreatePVZExpectation

	callArgs []*PVZRepositoryMockCreatePVZParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZRepositoryMockCreatePVZExpectation specifies expectation struct of the PVZRepository.CreatePVZ
type PVZRepositoryMockCreatePVZExpectation struct {
	mock               *PVZRepositoryMock
	params             *PVZRepositoryMockCreatePVZParams
	paramPtrs          *PVZRepositoryMockCreatePVZParamPtrs
	expectationOrigins PVZRepositoryMockCreatePVZExpectationOrigins
	results            *PVZRepositoryMockCreatePVZResults
	returnOrigin       string
	Counter            uint64
}

// PVZRepositoryMockCreatePVZParams contains parameters of the PVZRepository.CreatePVZ
type PVZRepositoryMockCreatePVZParams struct {
	ctx context.Context
	p   *model.PVZ
}

// PVZRepositoryMockCreatePVZParamPtrs contains pointers to parameters of the PVZRepository.CreatePVZ
type PVZRepositoryMockCreatePVZParamPtrs struct {
	ctx *context.Context
	p   **model.PVZ
}

// PVZRepositoryMockCreatePVZResults contains results of the PVZRepository.CreatePVZ
type PVZRepositoryMockCreatePVZResults struct {
	err error
}

// PVZRepositoryMockCreatePVZOrigins contains origins of expectations of the PVZRepository.CreatePVZ
type PVZRepositoryMockCreatePVZExpectationOrigins struct {
	origin    string
	originCtx string
	originP   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePVZ *mPVZRepositoryMockCreatePVZ) Optional() *mPVZRepositoryMockCreatePVZ {
	mmCreatePVZ.optional = true
	return mmCreatePVZ
}

// Expect sets up expected params for PVZRepository.CreatePVZ
func (mmCreatePVZ *mPVZRepositoryMockCreatePVZ) Expect(ctx context.Context, p *model.PVZ) *mPVZRepositoryMockCreatePVZ {
	if mmCreatePVZ.mock.funcCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("PVZRepositoryMock.CreatePVZ mock is already set by Set")
	}

	if mmCreatePVZ.defaultExpectation == nil {
		mmCreatePVZ.defaultExpectation = &PVZRepositoryMockCreatePVZExpectation{}
	}

	if mmCreatePVZ.defaultExpectation.paramPtrs != nil {
		mmCreatePVZ.mock.t.Fatalf("PVZRepositoryMock.CreatePVZ mock is already set by ExpectParams functions")
	}

	mmCreatePVZ.defaultExpectation.params = &PVZRepositoryMockCreatePVZParams{ctx, p}
	mmCreatePVZ.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePVZ.expectations {
		if minimock.Equal(e.params, mmCreatePVZ.defaultExpectation.params) {
			mmCreatePVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePVZ.defaultExpectation.params)
		}
	}

	return mmCreatePVZ
}

// ExpectCtxParam1 sets up expected param ctx for PVZRepository.CreatePVZ
func (mmCreatePVZ *mPVZRepositoryMockCreatePVZ) ExpectCtxParam1(ctx context.Context) *mPVZRepositoryMockCreatePVZ {
	if mmCreatePVZ.mock.funcCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("PVZRepositoryMock.CreatePVZ mock is already set by Set")
	}

	if mmCreatePVZ.defaultExpectation == nil {
		mmCreatePVZ.defaultExpectation = &PVZRepositoryMockCreatePVZExpectation{}
	}

	if mmCreatePVZ.defaultExpectation.params != nil {
		mmCreatePVZ.mock.t.Fatalf("PVZRepositoryMock.CreatePVZ mock is already set by Expect")
	}

	if mmCreatePVZ.defaultExpectation.paramPtrs == nil {
		mmCreatePVZ.defaultExpectation.paramPtrs = &PVZRepositoryMockCreatePVZParamPtrs{}
	}
	mmCreatePVZ.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePVZ.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePVZ
}

// ExpectPParam2 sets up expected param p for PVZRepository.CreatePVZ
func (mmCreatePVZ *mPVZRepositoryMockCreatePVZ) ExpectPParam2(p *model.PVZ) *mPVZRepositoryMockCreatePVZ {
	if mmCreatePVZ.mock.funcCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("PVZRepositoryMock.CreatePVZ mock is already set by Set")
	}

	if mmCreatePVZ.defaultExpectation == nil {
		mmCreatePVZ.defaultExpectation = &PVZRepositoryMockCreatePVZExpectation{}
	}

	if mmCreatePVZ.defaultExpectation.params != nil {
		mmCreatePVZ.mock.t.Fatalf("PVZRepositoryMock.CreatePVZ mock is already set by Expect")
	}

	if mmCreatePVZ.defaultExpectation.paramPtrs == nil {
		mmCreatePVZ.defaultExpectation.paramPtrs = &PVZRepositoryMockCreatePVZParamPtrs{}
	}
	mmCreatePVZ.defaultExpectation.paramPtrs.p = &p
	mmCreatePVZ.defaultExpectation.expectationOrigins.originP = minimock.CallerInfo(1)

	return mmCreatePVZ
}

// Inspect accepts an inspector function that has same arguments as the PVZRepository.CreatePVZ
func (mmCreatePVZ *mPVZRepositoryMockCreatePVZ) Inspect(f func(ctx context.Context, p *model.PVZ)) *mPVZRepositoryMockCreatePVZ {
	if mmCreatePVZ.mock.inspectFuncCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("Inspect function is already set for PVZRepositoryMock.CreatePVZ")
	}

	mmCreatePVZ.mock.inspectFuncCreatePVZ = f

	return mmCreatePVZ
}

// Return sets up results that will be returned by PVZRepository.CreatePVZ
func (mmCreatePVZ *mPVZRepositoryMockCreatePVZ) Return(err error) *PVZRepositoryMock {
	if mmCreatePVZ.mock.funcCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("PVZRepositoryMock.CreatePVZ mock is already set by Set")
	}

	if mmCreatePVZ.defaultExpectation == nil {
		mmCreatePVZ.defaultExpectation = &PVZRepositoryMockCreatePVZExpectation{mock: mmCreatePVZ.mock}
	}
	mmCreatePVZ.defaultExpectation.results = &PVZRepositoryMockCreatePVZResults{err}
	mmCreatePVZ.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePVZ.mock
}

// Set uses given function f to mock the PVZRepository.CreatePVZ method
func (mmCreatePVZ *mPVZRepositoryMockCreatePVZ) Set(f func(ctx context.Context, p *model.PVZ) (err error)) *PVZRepositoryMock {
	if mmCreatePVZ.defaultExpectation != nil {
		mmCreatePVZ.mock.t.Fatalf("Default expectation is already set for the PVZRepository.CreatePVZ method")
	}

	if len(mmCreatePVZ.expectations) > 0 {
		mmCreatePVZ.mock.t.Fatalf("Some expectations are already set for the PVZRepository.CreatePVZ method")
	}

	mmCreatePVZ.mock.funcCreatePVZ = f
	mmCreatePVZ.mock.funcCreatePVZOrigin = minimock.CallerInfo(1)
	return mmCreatePVZ.mock
}

// When sets expectation for the PVZRepository.CreatePVZ which will trigger the result defined by the following
// Then helper
func (mmCreatePVZ *mPVZRepositoryMockCreatePVZ) When(ctx context.Context, p *model.PVZ) *PVZRepositoryMockCreatePVZExpectation {
	if mmCreatePVZ.mock.funcCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("PVZRepositoryMock.CreatePVZ mock is already set by Set")
	}

	expectation := &PVZRepositoryMockCreatePVZExpectation{
		mock:               mmCreatePVZ.mock,
		params:             &PVZRepositoryMockCreatePVZParams{ctx, p},
		expectationOrigins: PVZRepositoryMockCreatePVZExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePVZ.expectations = append(mmCreatePVZ.expectations, expectation)
	return expectation
}

// Then sets up PVZRepository.CreatePVZ return parameters for the expectation previously defined by the When method
func (e *PVZRepositoryMockCreatePVZExpectation) Then(err error) *PVZRepositoryMock {
	e.results = &PVZRepositoryMockCreatePVZResults{err}
	return e.mock
}

// Times sets number of times PVZRepository.CreatePVZ should be invoked
func (mmCreatePVZ *mPVZRepositoryMockCreatePVZ) Times(n uint64) *mPVZRepositoryMockCreatePVZ {
	if n == 0 {
		mmCreatePVZ.mock.t.Fatalf("Times of PVZRepositoryMock.CreatePVZ mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePVZ.expectedInvocations, n)
	mmCreatePVZ.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePVZ
}

func (mmCreatePVZ *mPVZRepositoryMockCreatePVZ) invocationsDone() bool {
	if len(mmCreatePVZ.expectations) == 0 && mmCreatePVZ.defaultExpectation == nil && mmCreatePVZ.mock.funcCreatePVZ == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePVZ.mock.afterCreatePVZCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePVZ.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePVZ implements mm_pvzrepo.PVZRepository
func (mmCreatePVZ *PVZRepositoryMock) CreatePVZ(ctx context.Context, p *model.PVZ) (err error) {
	mm_atomic.AddUint64(&mmCreatePVZ.beforeCreatePVZCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePVZ.afterCreatePVZCounter, 1)

	mmCreatePVZ.t.Helper()

	if mmCreatePVZ.inspectFuncCreatePVZ != nil {
		mmCreatePVZ.inspectFuncCreatePVZ(ctx, p)
	}

	mm_params := PVZRepositoryMockCreatePVZParams{ctx, p}

	// Record call args
	mmCreatePVZ.CreatePVZMock.mutex.Lock()
	mmCreatePVZ.CreatePVZMock.callArgs = append(mmCreatePVZ.CreatePVZMock.callArgs, &mm_params)
	mmCreatePVZ.CreatePVZMock.mutex.Unlock()

	for _, e := range mmCreatePVZ.CreatePVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreatePVZ.CreatePVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePVZ.CreatePVZMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePVZ.CreatePVZMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePVZ.CreatePVZMock.defaultExpectation.paramPtrs

		mm_got := PVZRepositoryMockCreatePVZParams{ctx, p}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePVZ.t.Errorf("PVZRepositoryMock.CreatePVZ got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePVZ.CreatePVZMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.p != nil && !minimock.Equal(*mm_want_ptrs.p, mm_got.p) {
				mmCreatePVZ.t.Errorf("PVZRepositoryMock.CreatePVZ got unexpected parameter p, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePVZ.CreatePVZMock.defaultExpectation.expectationOrigins.originP, *mm_want_ptrs.p, mm_got.p, minimock.Diff(*mm_want_ptrs.p, mm_got.p))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePVZ.t.Errorf("PVZRepositoryMock.CreatePVZ got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePVZ.CreatePVZMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePVZ.CreatePVZMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePVZ.t.Fatal("No results are set for the PVZRepositoryMock.CreatePVZ")
		}
		return (*mm_results).err
	}
	if mmCreatePVZ.funcCreatePVZ != nil {
		return mmCreatePVZ.funcCreatePVZ(ctx, p)
	}
	mmCreatePVZ.t.Fatalf("Unexpected call to PVZRepositoryMock.CreatePVZ. %v %v", ctx, p)
	return
}

// CreatePVZAfterCounter returns a count of finished PVZRepositoryMock.CreatePVZ invocations
func (mmCreatePVZ *PVZRepositoryMock) CreatePVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePVZ.afterCreatePVZCounter)
}

// CreatePVZBeforeCounter returns a count of PVZRepositoryMock.CreatePVZ invocations
func (mmCreatePVZ *PVZRepositoryMock) CreatePVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePVZ.beforeCreatePVZCounter)
}

// Calls returns a list of arguments used in each call to PVZRepositoryMock.CreatePVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePVZ *mPVZRepositoryMockCreatePVZ) Calls() []*PVZRepositoryMockCreatePVZParams {
	mmCreatePVZ.mutex.RLock()

	argCopy := make([]*PVZRepositoryMockCreatePVZParams, len(mmCreatePVZ.callArgs))
	copy(argCopy, mmCreatePVZ.callArgs)

	mmCreatePVZ.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePVZDone returns true if the count of the CreatePVZ invocations corresponds
// the number of defined expectations
func (m *PVZRepositoryMock) MinimockCreatePVZDone() bool {
	if m.CreatePVZMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePVZMock.invocationsDone()
}

// MinimockCreatePVZInspect logs each unmet expectation
func (m *PVZRepositoryMock) MinimockCreatePVZInspect() {
	for _, e := range m.CreatePVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZRepositoryMock.CreatePVZ at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePVZCounter := mm_atomic.LoadUint64(&m.afterCreatePVZCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePVZMock.defaultExpectation != nil && afterCreatePVZCounter < 1 {
		if m.CreatePVZMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZRepositoryMock.CreatePVZ at\n%s", m.CreatePVZMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZRepositoryMock.CreatePVZ at\n%s with params: %#v", m.CreatePVZMock.defaultExpectation.expectationOrigins.origin, *m.CreatePVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePVZ != nil && afterCreatePVZCounter < 1 {
		m.t.Errorf("Expected call to PVZRepositoryMock.CreatePVZ at\n%s", m.funcCreatePVZOrigin)
	}

	if !m.CreatePVZMock.invocationsDone() && afterCreatePVZCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZRepositoryMock.CreatePVZ at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePVZMock.expectedInvocations), m.CreatePVZMock.expectedInvocationsOrigin, afterCreatePVZCounter)
	}
}

type mPVZRepositoryMockGetPVZ struct {
	optional           bool
	mock               *PVZRepositoryMock
	defaultExpectation *PVZRepositoryMockGetPVZExpectation
	expectations       []*PVZRepositoryMockGetPVZExpectation

	callArgs []*PVZRepositoryMockGetPVZParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PVZRepositoryMockGetPVZExpectation specifies expectation struct of the PVZRepository.GetPVZ
type PVZRepositoryMockGetPVZExpectation struct {
	mock               *PVZRepositoryMock
	params             *PVZRepositoryMockGetPVZParams
	paramPtrs          *PVZRepositoryMockGetPVZParamPtrs
	expectationOrigins PVZRepositoryMockGetPVZExpectationOrigins
	results            *PVZRepositoryMockGetPVZResults
	returnOrigin       string
	Counter            uint64
}

// PVZRepositoryMockGetPVZParams contains parameters of the PVZRepository.GetPVZ
type PVZRepositoryMockGetPVZParams struct {
	ctx    context.Context
	params *pvz.PVZFilter
}

// PVZRepositoryMockGetPVZParamPtrs contains pointers to parameters of the PVZRepository.GetPVZ
type PVZRepositoryMockGetPVZParamPtrs struct {
	ctx    *context.Context
	params **pvz.PVZFilter
}

// PVZRepositoryMockGetPVZResults contains results of the PVZRepository.GetPVZ
type PVZRepositoryMockGetPVZResults struct {
	pa1 []pvz.PVZ
	err error
}

// PVZRepositoryMockGetPVZOrigins contains origins of expectations of the PVZRepository.GetPVZ
type PVZRepositoryMockGetPVZExpectationOrigins struct {
	origin       string
	originCtx    string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPVZ *mPVZRepositoryMockGetPVZ) Optional() *mPVZRepositoryMockGetPVZ {
	mmGetPVZ.optional = true
	return mmGetPVZ
}

// Expect sets up expected params for PVZRepository.GetPVZ
func (mmGetPVZ *mPVZRepositoryMockGetPVZ) Expect(ctx context.Context, params *pvz.PVZFilter) *mPVZRepositoryMockGetPVZ {
	if mmGetPVZ.mock.funcGetPVZ != nil {
		mmGetPVZ.mock.t.Fatalf("PVZRepositoryMock.GetPVZ mock is already set by Set")
	}

	if mmGetPVZ.defaultExpectation == nil {
		mmGetPVZ.defaultExpectation = &PVZRepositoryMockGetPVZExpectation{}
	}

	if mmGetPVZ.defaultExpectation.paramPtrs != nil {
		mmGetPVZ.mock.t.Fatalf("PVZRepositoryMock.GetPVZ mock is already set by ExpectParams functions")
	}

	mmGetPVZ.defaultExpectation.params = &PVZRepositoryMockGetPVZParams{ctx, params}
	mmGetPVZ.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPVZ.expectations {
		if minimock.Equal(e.params, mmGetPVZ.defaultExpectation.params) {
			mmGetPVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPVZ.defaultExpectation.params)
		}
	}

	return mmGetPVZ
}

// ExpectCtxParam1 sets up expected param ctx for PVZRepository.GetPVZ
func (mmGetPVZ *mPVZRepositoryMockGetPVZ) ExpectCtxParam1(ctx context.Context) *mPVZRepositoryMockGetPVZ {
	if mmGetPVZ.mock.funcGetPVZ != nil {
		mmGetPVZ.mock.t.Fatalf("PVZRepositoryMock.GetPVZ mock is already set by Set")
	}

	if mmGetPVZ.defaultExpectation == nil {
		mmGetPVZ.defaultExpectation = &PVZRepositoryMockGetPVZExpectation{}
	}

	if mmGetPVZ.defaultExpectation.params != nil {
		mmGetPVZ.mock.t.Fatalf("PVZRepositoryMock.GetPVZ mock is already set by Expect")
	}

	if mmGetPVZ.defaultExpectation.paramPtrs == nil {
		mmGetPVZ.defaultExpectation.paramPtrs = &PVZRepositoryMockGetPVZParamPtrs{}
	}
	mmGetPVZ.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPVZ.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPVZ
}

// ExpectParamsParam2 sets up expected param params for PVZRepository.GetPVZ
func (mmGetPVZ *mPVZRepositoryMockGetPVZ) ExpectParamsParam2(params *pvz.PVZFilter) *mPVZRepositoryMockGetPVZ {
	if mmGetPVZ.mock.funcGetPVZ != nil {
		mmGetPVZ.mock.t.Fatalf("PVZRepositoryMock.GetPVZ mock is already set by Set")
	}

	if mmGetPVZ.defaultExpectation == nil {
		mmGetPVZ.defaultExpectation = &PVZRepositoryMockGetPVZExpectation{}
	}

	if mmGetPVZ.defaultExpectation.params != nil {
		mmGetPVZ.mock.t.Fatalf("PVZRepositoryMock.GetPVZ mock is already set by Expect")
	}

	if mmGetPVZ.defaultExpectation.paramPtrs == nil {
		mmGetPVZ.defaultExpectation.paramPtrs = &PVZRepositoryMockGetPVZParamPtrs{}
	}
	mmGetPVZ.defaultExpectation.paramPtrs.params = &params
	mmGetPVZ.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmGetPVZ
}

// Inspect accepts an inspector function that has same arguments as the PVZRepository.GetPVZ
func (mmGetPVZ *mPVZRepositoryMockGetPVZ) Inspect(f func(ctx context.Context, params *pvz.PVZFilter)) *mPVZRepositoryMockGetPVZ {
	if mmGetPVZ.mock.inspectFuncGetPVZ != nil {
		mmGetPVZ.mock.t.Fatalf("Inspect function is already set for PVZRepositoryMock.GetPVZ")
	}

	mmGetPVZ.mock.inspectFuncGetPVZ = f

	return mmGetPVZ
}

// Return sets up results that will be returned by PVZRepository.GetPVZ
func (mmGetPVZ *mPVZRepositoryMockGetPVZ) Return(pa1 []pvz.PVZ, err error) *PVZRepositoryMock {
	if mmGetPVZ.mock.funcGetPVZ != nil {
		mmGetPVZ.mock.t.Fatalf("PVZRepositoryMock.GetPVZ mock is already set by Set")
	}

	if mmGetPVZ.defaultExpectation == nil {
		mmGetPVZ.defaultExpectation = &PVZRepositoryMockGetPVZExpectation{mock: mmGetPVZ.mock}
	}
	mmGetPVZ.defaultExpectation.results = &PVZRepositoryMockGetPVZResults{pa1, err}
	mmGetPVZ.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPVZ.mock
}

// Set uses given function f to mock the PVZRepository.GetPVZ method
func (mmGetPVZ *mPVZRepositoryMockGetPVZ) Set(f func(ctx context.Context, params *pvz.PVZFilter) (pa1 []pvz.PVZ, err error)) *PVZRepositoryMock {
	if mmGetPVZ.defaultExpectation != nil {
		mmGetPVZ.mock.t.Fatalf("Default expectation is already set for the PVZRepository.GetPVZ method")
	}

	if len(mmGetPVZ.expectations) > 0 {
		mmGetPVZ.mock.t.Fatalf("Some expectations are already set for the PVZRepository.GetPVZ method")
	}

	mmGetPVZ.mock.funcGetPVZ = f
	mmGetPVZ.mock.funcGetPVZOrigin = minimock.CallerInfo(1)
	return mmGetPVZ.mock
}

// When sets expectation for the PVZRepository.GetPVZ which will trigger the result defined by the following
// Then helper
func (mmGetPVZ *mPVZRepositoryMockGetPVZ) When(ctx context.Context, params *pvz.PVZFilter) *PVZRepositoryMockGetPVZExpectation {
	if mmGetPVZ.mock.funcGetPVZ != nil {
		mmGetPVZ.mock.t.Fatalf("PVZRepositoryMock.GetPVZ mock is already set by Set")
	}

	expectation := &PVZRepositoryMockGetPVZExpectation{
		mock:               mmGetPVZ.mock,
		params:             &PVZRepositoryMockGetPVZParams{ctx, params},
		expectationOrigins: PVZRepositoryMockGetPVZExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPVZ.expectations = append(mmGetPVZ.expectations, expectation)
	return expectation
}

// Then sets up PVZRepository.GetPVZ return parameters for the expectation previously defined by the When method
func (e *PVZRepositoryMockGetPVZExpectation) Then(pa1 []pvz.PVZ, err error) *PVZRepositoryMock {
	e.results = &PVZRepositoryMockGetPVZResults{pa1, err}
	return e.mock
}

// Times sets number of times PVZRepository.GetPVZ should be invoked
func (mmGetPVZ *mPVZRepositoryMockGetPVZ) Times(n uint64) *mPVZRepositoryMockGetPVZ {
	if n == 0 {
		mmGetPVZ.mock.t.Fatalf("Times of PVZRepositoryMock.GetPVZ mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPVZ.expectedInvocations, n)
	mmGetPVZ.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPVZ
}

func (mmGetPVZ *mPVZRepositoryMockGetPVZ) invocationsDone() bool {
	if len(mmGetPVZ.expectations) == 0 && mmGetPVZ.defaultExpectation == nil && mmGetPVZ.mock.funcGetPVZ == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPVZ.mock.afterGetPVZCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPVZ.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPVZ implements mm_pvzrepo.PVZRepository
func (mmGetPVZ *PVZRepositoryMock) GetPVZ(ctx context.Context, params *pvz.PVZFilter) (pa1 []pvz.PVZ, err error) {
	mm_atomic.AddUint64(&mmGetPVZ.beforeGetPVZCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPVZ.afterGetPVZCounter, 1)

	mmGetPVZ.t.Helper()

	if mmGetPVZ.inspectFuncGetPVZ != nil {
		mmGetPVZ.inspectFuncGetPVZ(ctx, params)
	}

	mm_params := PVZRepositoryMockGetPVZParams{ctx, params}

	// Record call args
	mmGetPVZ.GetPVZMock.mutex.Lock()
	mmGetPVZ.GetPVZMock.callArgs = append(mmGetPVZ.GetPVZMock.callArgs, &mm_params)
	mmGetPVZ.GetPVZMock.mutex.Unlock()

	for _, e := range mmGetPVZ.GetPVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetPVZ.GetPVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPVZ.GetPVZMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPVZ.GetPVZMock.defaultExpectation.params
		mm_want_ptrs := mmGetPVZ.GetPVZMock.defaultExpectation.paramPtrs

		mm_got := PVZRepositoryMockGetPVZParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPVZ.t.Errorf("PVZRepositoryMock.GetPVZ got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPVZ.GetPVZMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmGetPVZ.t.Errorf("PVZRepositoryMock.GetPVZ got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPVZ.GetPVZMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPVZ.t.Errorf("PVZRepositoryMock.GetPVZ got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPVZ.GetPVZMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPVZ.GetPVZMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPVZ.t.Fatal("No results are set for the PVZRepositoryMock.GetPVZ")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetPVZ.funcGetPVZ != nil {
		return mmGetPVZ.funcGetPVZ(ctx, params)
	}
	mmGetPVZ.t.Fatalf("Unexpected call to PVZRepositoryMock.GetPVZ. %v %v", ctx, params)
	return
}

// GetPVZAfterCounter returns a count of finished PVZRepositoryMock.GetPVZ invocations
func (mmGetPVZ *PVZRepositoryMock) GetPVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPVZ.afterGetPVZCounter)
}

// GetPVZBeforeCounter returns a count of PVZRepositoryMock.GetPVZ invocations
func (mmGetPVZ *PVZRepositoryMock) GetPVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPVZ.beforeGetPVZCounter)
}

// Calls returns a list of arguments used in each call to PVZRepositoryMock.GetPVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPVZ *mPVZRepositoryMockGetPVZ) Calls() []*PVZRepositoryMockGetPVZParams {
	mmGetPVZ.mutex.RLock()

	argCopy := make([]*PVZRepositoryMockGetPVZParams, len(mmGetPVZ.callArgs))
	copy(argCopy, mmGetPVZ.callArgs)

	mmGetPVZ.mutex.RUnlock()

	return argCopy
}

// MinimockGetPVZDone returns true if the count of the GetPVZ invocations corresponds
// the number of defined expectations
func (m *PVZRepositoryMock) MinimockGetPVZDone() bool {
	if m.GetPVZMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPVZMock.invocationsDone()
}

// MinimockGetPVZInspect logs each unmet expectation
func (m *PVZRepositoryMock) MinimockGetPVZInspect() {
	for _, e := range m.GetPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PVZRepositoryMock.GetPVZ at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPVZCounter := mm_atomic.LoadUint64(&m.afterGetPVZCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPVZMock.defaultExpectation != nil && afterGetPVZCounter < 1 {
		if m.GetPVZMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PVZRepositoryMock.GetPVZ at\n%s", m.GetPVZMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PVZRepositoryMock.GetPVZ at\n%s with params: %#v", m.GetPVZMock.defaultExpectation.expectationOrigins.origin, *m.GetPVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPVZ != nil && afterGetPVZCounter < 1 {
		m.t.Errorf("Expected call to PVZRepositoryMock.GetPVZ at\n%s", m.funcGetPVZOrigin)
	}

	if !m.GetPVZMock.invocationsDone() && afterGetPVZCounter > 0 {
		m.t.Errorf("Expected %d calls to PVZRepositoryMock.GetPVZ at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPVZMock.expectedInvocations), m.GetPVZMock.expectedInvocationsOrigin, afterGetPVZCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PVZRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreatePVZInspect()

			m.MinimockGetPVZInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PVZRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PVZRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreatePVZDone() &&
		m.MinimockGetPVZDone()
}
