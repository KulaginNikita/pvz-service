// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/KulaginNikita/pvz-service/internal/service.ReceptionService -o reception_service_mock.go -n ReceptionServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/KulaginNikita/pvz-service/internal/domain/reception"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// ReceptionServiceMock implements mm_service.ReceptionService
type ReceptionServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCloseReception          func(ctx context.Context, pvzid uuid.UUID) (err error)
	funcCloseReceptionOrigin    string
	inspectFuncCloseReception   func(ctx context.Context, pvzid uuid.UUID)
	afterCloseReceptionCounter  uint64
	beforeCloseReceptionCounter uint64
	CloseReceptionMock          mReceptionServiceMockCloseReception

	funcCreateReception          func(ctx context.Context, r *reception.Reception) (rp1 *reception.Reception, err error)
	funcCreateReceptionOrigin    string
	inspectFuncCreateReception   func(ctx context.Context, r *reception.Reception)
	afterCreateReceptionCounter  uint64
	beforeCreateReceptionCounter uint64
	CreateReceptionMock          mReceptionServiceMockCreateReception
}

// NewReceptionServiceMock returns a mock for mm_service.ReceptionService
func NewReceptionServiceMock(t minimock.Tester) *ReceptionServiceMock {
	m := &ReceptionServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseReceptionMock = mReceptionServiceMockCloseReception{mock: m}
	m.CloseReceptionMock.callArgs = []*ReceptionServiceMockCloseReceptionParams{}

	m.CreateReceptionMock = mReceptionServiceMockCreateReception{mock: m}
	m.CreateReceptionMock.callArgs = []*ReceptionServiceMockCreateReceptionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mReceptionServiceMockCloseReception struct {
	optional           bool
	mock               *ReceptionServiceMock
	defaultExpectation *ReceptionServiceMockCloseReceptionExpectation
	expectations       []*ReceptionServiceMockCloseReceptionExpectation

	callArgs []*ReceptionServiceMockCloseReceptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionServiceMockCloseReceptionExpectation specifies expectation struct of the ReceptionService.CloseReception
type ReceptionServiceMockCloseReceptionExpectation struct {
	mock               *ReceptionServiceMock
	params             *ReceptionServiceMockCloseReceptionParams
	paramPtrs          *ReceptionServiceMockCloseReceptionParamPtrs
	expectationOrigins ReceptionServiceMockCloseReceptionExpectationOrigins
	results            *ReceptionServiceMockCloseReceptionResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionServiceMockCloseReceptionParams contains parameters of the ReceptionService.CloseReception
type ReceptionServiceMockCloseReceptionParams struct {
	ctx   context.Context
	pvzid uuid.UUID
}

// ReceptionServiceMockCloseReceptionParamPtrs contains pointers to parameters of the ReceptionService.CloseReception
type ReceptionServiceMockCloseReceptionParamPtrs struct {
	ctx   *context.Context
	pvzid *uuid.UUID
}

// ReceptionServiceMockCloseReceptionResults contains results of the ReceptionService.CloseReception
type ReceptionServiceMockCloseReceptionResults struct {
	err error
}

// ReceptionServiceMockCloseReceptionOrigins contains origins of expectations of the ReceptionService.CloseReception
type ReceptionServiceMockCloseReceptionExpectationOrigins struct {
	origin      string
	originCtx   string
	originPvzid string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCloseReception *mReceptionServiceMockCloseReception) Optional() *mReceptionServiceMockCloseReception {
	mmCloseReception.optional = true
	return mmCloseReception
}

// Expect sets up expected params for ReceptionService.CloseReception
func (mmCloseReception *mReceptionServiceMockCloseReception) Expect(ctx context.Context, pvzid uuid.UUID) *mReceptionServiceMockCloseReception {
	if mmCloseReception.mock.funcCloseReception != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionServiceMock.CloseReception mock is already set by Set")
	}

	if mmCloseReception.defaultExpectation == nil {
		mmCloseReception.defaultExpectation = &ReceptionServiceMockCloseReceptionExpectation{}
	}

	if mmCloseReception.defaultExpectation.paramPtrs != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionServiceMock.CloseReception mock is already set by ExpectParams functions")
	}

	mmCloseReception.defaultExpectation.params = &ReceptionServiceMockCloseReceptionParams{ctx, pvzid}
	mmCloseReception.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCloseReception.expectations {
		if minimock.Equal(e.params, mmCloseReception.defaultExpectation.params) {
			mmCloseReception.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCloseReception.defaultExpectation.params)
		}
	}

	return mmCloseReception
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionService.CloseReception
func (mmCloseReception *mReceptionServiceMockCloseReception) ExpectCtxParam1(ctx context.Context) *mReceptionServiceMockCloseReception {
	if mmCloseReception.mock.funcCloseReception != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionServiceMock.CloseReception mock is already set by Set")
	}

	if mmCloseReception.defaultExpectation == nil {
		mmCloseReception.defaultExpectation = &ReceptionServiceMockCloseReceptionExpectation{}
	}

	if mmCloseReception.defaultExpectation.params != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionServiceMock.CloseReception mock is already set by Expect")
	}

	if mmCloseReception.defaultExpectation.paramPtrs == nil {
		mmCloseReception.defaultExpectation.paramPtrs = &ReceptionServiceMockCloseReceptionParamPtrs{}
	}
	mmCloseReception.defaultExpectation.paramPtrs.ctx = &ctx
	mmCloseReception.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCloseReception
}

// ExpectPvzidParam2 sets up expected param pvzid for ReceptionService.CloseReception
func (mmCloseReception *mReceptionServiceMockCloseReception) ExpectPvzidParam2(pvzid uuid.UUID) *mReceptionServiceMockCloseReception {
	if mmCloseReception.mock.funcCloseReception != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionServiceMock.CloseReception mock is already set by Set")
	}

	if mmCloseReception.defaultExpectation == nil {
		mmCloseReception.defaultExpectation = &ReceptionServiceMockCloseReceptionExpectation{}
	}

	if mmCloseReception.defaultExpectation.params != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionServiceMock.CloseReception mock is already set by Expect")
	}

	if mmCloseReception.defaultExpectation.paramPtrs == nil {
		mmCloseReception.defaultExpectation.paramPtrs = &ReceptionServiceMockCloseReceptionParamPtrs{}
	}
	mmCloseReception.defaultExpectation.paramPtrs.pvzid = &pvzid
	mmCloseReception.defaultExpectation.expectationOrigins.originPvzid = minimock.CallerInfo(1)

	return mmCloseReception
}

// Inspect accepts an inspector function that has same arguments as the ReceptionService.CloseReception
func (mmCloseReception *mReceptionServiceMockCloseReception) Inspect(f func(ctx context.Context, pvzid uuid.UUID)) *mReceptionServiceMockCloseReception {
	if mmCloseReception.mock.inspectFuncCloseReception != nil {
		mmCloseReception.mock.t.Fatalf("Inspect function is already set for ReceptionServiceMock.CloseReception")
	}

	mmCloseReception.mock.inspectFuncCloseReception = f

	return mmCloseReception
}

// Return sets up results that will be returned by ReceptionService.CloseReception
func (mmCloseReception *mReceptionServiceMockCloseReception) Return(err error) *ReceptionServiceMock {
	if mmCloseReception.mock.funcCloseReception != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionServiceMock.CloseReception mock is already set by Set")
	}

	if mmCloseReception.defaultExpectation == nil {
		mmCloseReception.defaultExpectation = &ReceptionServiceMockCloseReceptionExpectation{mock: mmCloseReception.mock}
	}
	mmCloseReception.defaultExpectation.results = &ReceptionServiceMockCloseReceptionResults{err}
	mmCloseReception.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCloseReception.mock
}

// Set uses given function f to mock the ReceptionService.CloseReception method
func (mmCloseReception *mReceptionServiceMockCloseReception) Set(f func(ctx context.Context, pvzid uuid.UUID) (err error)) *ReceptionServiceMock {
	if mmCloseReception.defaultExpectation != nil {
		mmCloseReception.mock.t.Fatalf("Default expectation is already set for the ReceptionService.CloseReception method")
	}

	if len(mmCloseReception.expectations) > 0 {
		mmCloseReception.mock.t.Fatalf("Some expectations are already set for the ReceptionService.CloseReception method")
	}

	mmCloseReception.mock.funcCloseReception = f
	mmCloseReception.mock.funcCloseReceptionOrigin = minimock.CallerInfo(1)
	return mmCloseReception.mock
}

// When sets expectation for the ReceptionService.CloseReception which will trigger the result defined by the following
// Then helper
func (mmCloseReception *mReceptionServiceMockCloseReception) When(ctx context.Context, pvzid uuid.UUID) *ReceptionServiceMockCloseReceptionExpectation {
	if mmCloseReception.mock.funcCloseReception != nil {
		mmCloseReception.mock.t.Fatalf("ReceptionServiceMock.CloseReception mock is already set by Set")
	}

	expectation := &ReceptionServiceMockCloseReceptionExpectation{
		mock:               mmCloseReception.mock,
		params:             &ReceptionServiceMockCloseReceptionParams{ctx, pvzid},
		expectationOrigins: ReceptionServiceMockCloseReceptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCloseReception.expectations = append(mmCloseReception.expectations, expectation)
	return expectation
}

// Then sets up ReceptionService.CloseReception return parameters for the expectation previously defined by the When method
func (e *ReceptionServiceMockCloseReceptionExpectation) Then(err error) *ReceptionServiceMock {
	e.results = &ReceptionServiceMockCloseReceptionResults{err}
	return e.mock
}

// Times sets number of times ReceptionService.CloseReception should be invoked
func (mmCloseReception *mReceptionServiceMockCloseReception) Times(n uint64) *mReceptionServiceMockCloseReception {
	if n == 0 {
		mmCloseReception.mock.t.Fatalf("Times of ReceptionServiceMock.CloseReception mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCloseReception.expectedInvocations, n)
	mmCloseReception.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCloseReception
}

func (mmCloseReception *mReceptionServiceMockCloseReception) invocationsDone() bool {
	if len(mmCloseReception.expectations) == 0 && mmCloseReception.defaultExpectation == nil && mmCloseReception.mock.funcCloseReception == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCloseReception.mock.afterCloseReceptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCloseReception.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CloseReception implements mm_service.ReceptionService
func (mmCloseReception *ReceptionServiceMock) CloseReception(ctx context.Context, pvzid uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmCloseReception.beforeCloseReceptionCounter, 1)
	defer mm_atomic.AddUint64(&mmCloseReception.afterCloseReceptionCounter, 1)

	mmCloseReception.t.Helper()

	if mmCloseReception.inspectFuncCloseReception != nil {
		mmCloseReception.inspectFuncCloseReception(ctx, pvzid)
	}

	mm_params := ReceptionServiceMockCloseReceptionParams{ctx, pvzid}

	// Record call args
	mmCloseReception.CloseReceptionMock.mutex.Lock()
	mmCloseReception.CloseReceptionMock.callArgs = append(mmCloseReception.CloseReceptionMock.callArgs, &mm_params)
	mmCloseReception.CloseReceptionMock.mutex.Unlock()

	for _, e := range mmCloseReception.CloseReceptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCloseReception.CloseReceptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCloseReception.CloseReceptionMock.defaultExpectation.Counter, 1)
		mm_want := mmCloseReception.CloseReceptionMock.defaultExpectation.params
		mm_want_ptrs := mmCloseReception.CloseReceptionMock.defaultExpectation.paramPtrs

		mm_got := ReceptionServiceMockCloseReceptionParams{ctx, pvzid}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCloseReception.t.Errorf("ReceptionServiceMock.CloseReception got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCloseReception.CloseReceptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvzid != nil && !minimock.Equal(*mm_want_ptrs.pvzid, mm_got.pvzid) {
				mmCloseReception.t.Errorf("ReceptionServiceMock.CloseReception got unexpected parameter pvzid, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCloseReception.CloseReceptionMock.defaultExpectation.expectationOrigins.originPvzid, *mm_want_ptrs.pvzid, mm_got.pvzid, minimock.Diff(*mm_want_ptrs.pvzid, mm_got.pvzid))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCloseReception.t.Errorf("ReceptionServiceMock.CloseReception got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCloseReception.CloseReceptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCloseReception.CloseReceptionMock.defaultExpectation.results
		if mm_results == nil {
			mmCloseReception.t.Fatal("No results are set for the ReceptionServiceMock.CloseReception")
		}
		return (*mm_results).err
	}
	if mmCloseReception.funcCloseReception != nil {
		return mmCloseReception.funcCloseReception(ctx, pvzid)
	}
	mmCloseReception.t.Fatalf("Unexpected call to ReceptionServiceMock.CloseReception. %v %v", ctx, pvzid)
	return
}

// CloseReceptionAfterCounter returns a count of finished ReceptionServiceMock.CloseReception invocations
func (mmCloseReception *ReceptionServiceMock) CloseReceptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseReception.afterCloseReceptionCounter)
}

// CloseReceptionBeforeCounter returns a count of ReceptionServiceMock.CloseReception invocations
func (mmCloseReception *ReceptionServiceMock) CloseReceptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseReception.beforeCloseReceptionCounter)
}

// Calls returns a list of arguments used in each call to ReceptionServiceMock.CloseReception.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCloseReception *mReceptionServiceMockCloseReception) Calls() []*ReceptionServiceMockCloseReceptionParams {
	mmCloseReception.mutex.RLock()

	argCopy := make([]*ReceptionServiceMockCloseReceptionParams, len(mmCloseReception.callArgs))
	copy(argCopy, mmCloseReception.callArgs)

	mmCloseReception.mutex.RUnlock()

	return argCopy
}

// MinimockCloseReceptionDone returns true if the count of the CloseReception invocations corresponds
// the number of defined expectations
func (m *ReceptionServiceMock) MinimockCloseReceptionDone() bool {
	if m.CloseReceptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CloseReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CloseReceptionMock.invocationsDone()
}

// MinimockCloseReceptionInspect logs each unmet expectation
func (m *ReceptionServiceMock) MinimockCloseReceptionInspect() {
	for _, e := range m.CloseReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionServiceMock.CloseReception at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCloseReceptionCounter := mm_atomic.LoadUint64(&m.afterCloseReceptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CloseReceptionMock.defaultExpectation != nil && afterCloseReceptionCounter < 1 {
		if m.CloseReceptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionServiceMock.CloseReception at\n%s", m.CloseReceptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionServiceMock.CloseReception at\n%s with params: %#v", m.CloseReceptionMock.defaultExpectation.expectationOrigins.origin, *m.CloseReceptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseReception != nil && afterCloseReceptionCounter < 1 {
		m.t.Errorf("Expected call to ReceptionServiceMock.CloseReception at\n%s", m.funcCloseReceptionOrigin)
	}

	if !m.CloseReceptionMock.invocationsDone() && afterCloseReceptionCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionServiceMock.CloseReception at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CloseReceptionMock.expectedInvocations), m.CloseReceptionMock.expectedInvocationsOrigin, afterCloseReceptionCounter)
	}
}

type mReceptionServiceMockCreateReception struct {
	optional           bool
	mock               *ReceptionServiceMock
	defaultExpectation *ReceptionServiceMockCreateReceptionExpectation
	expectations       []*ReceptionServiceMockCreateReceptionExpectation

	callArgs []*ReceptionServiceMockCreateReceptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReceptionServiceMockCreateReceptionExpectation specifies expectation struct of the ReceptionService.CreateReception
type ReceptionServiceMockCreateReceptionExpectation struct {
	mock               *ReceptionServiceMock
	params             *ReceptionServiceMockCreateReceptionParams
	paramPtrs          *ReceptionServiceMockCreateReceptionParamPtrs
	expectationOrigins ReceptionServiceMockCreateReceptionExpectationOrigins
	results            *ReceptionServiceMockCreateReceptionResults
	returnOrigin       string
	Counter            uint64
}

// ReceptionServiceMockCreateReceptionParams contains parameters of the ReceptionService.CreateReception
type ReceptionServiceMockCreateReceptionParams struct {
	ctx context.Context
	r   *reception.Reception
}

// ReceptionServiceMockCreateReceptionParamPtrs contains pointers to parameters of the ReceptionService.CreateReception
type ReceptionServiceMockCreateReceptionParamPtrs struct {
	ctx *context.Context
	r   **reception.Reception
}

// ReceptionServiceMockCreateReceptionResults contains results of the ReceptionService.CreateReception
type ReceptionServiceMockCreateReceptionResults struct {
	rp1 *reception.Reception
	err error
}

// ReceptionServiceMockCreateReceptionOrigins contains origins of expectations of the ReceptionService.CreateReception
type ReceptionServiceMockCreateReceptionExpectationOrigins struct {
	origin    string
	originCtx string
	originR   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateReception *mReceptionServiceMockCreateReception) Optional() *mReceptionServiceMockCreateReception {
	mmCreateReception.optional = true
	return mmCreateReception
}

// Expect sets up expected params for ReceptionService.CreateReception
func (mmCreateReception *mReceptionServiceMockCreateReception) Expect(ctx context.Context, r *reception.Reception) *mReceptionServiceMockCreateReception {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Set")
	}

	if mmCreateReception.defaultExpectation == nil {
		mmCreateReception.defaultExpectation = &ReceptionServiceMockCreateReceptionExpectation{}
	}

	if mmCreateReception.defaultExpectation.paramPtrs != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by ExpectParams functions")
	}

	mmCreateReception.defaultExpectation.params = &ReceptionServiceMockCreateReceptionParams{ctx, r}
	mmCreateReception.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateReception.expectations {
		if minimock.Equal(e.params, mmCreateReception.defaultExpectation.params) {
			mmCreateReception.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateReception.defaultExpectation.params)
		}
	}

	return mmCreateReception
}

// ExpectCtxParam1 sets up expected param ctx for ReceptionService.CreateReception
func (mmCreateReception *mReceptionServiceMockCreateReception) ExpectCtxParam1(ctx context.Context) *mReceptionServiceMockCreateReception {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Set")
	}

	if mmCreateReception.defaultExpectation == nil {
		mmCreateReception.defaultExpectation = &ReceptionServiceMockCreateReceptionExpectation{}
	}

	if mmCreateReception.defaultExpectation.params != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Expect")
	}

	if mmCreateReception.defaultExpectation.paramPtrs == nil {
		mmCreateReception.defaultExpectation.paramPtrs = &ReceptionServiceMockCreateReceptionParamPtrs{}
	}
	mmCreateReception.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateReception.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateReception
}

// ExpectRParam2 sets up expected param r for ReceptionService.CreateReception
func (mmCreateReception *mReceptionServiceMockCreateReception) ExpectRParam2(r *reception.Reception) *mReceptionServiceMockCreateReception {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Set")
	}

	if mmCreateReception.defaultExpectation == nil {
		mmCreateReception.defaultExpectation = &ReceptionServiceMockCreateReceptionExpectation{}
	}

	if mmCreateReception.defaultExpectation.params != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Expect")
	}

	if mmCreateReception.defaultExpectation.paramPtrs == nil {
		mmCreateReception.defaultExpectation.paramPtrs = &ReceptionServiceMockCreateReceptionParamPtrs{}
	}
	mmCreateReception.defaultExpectation.paramPtrs.r = &r
	mmCreateReception.defaultExpectation.expectationOrigins.originR = minimock.CallerInfo(1)

	return mmCreateReception
}

// Inspect accepts an inspector function that has same arguments as the ReceptionService.CreateReception
func (mmCreateReception *mReceptionServiceMockCreateReception) Inspect(f func(ctx context.Context, r *reception.Reception)) *mReceptionServiceMockCreateReception {
	if mmCreateReception.mock.inspectFuncCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("Inspect function is already set for ReceptionServiceMock.CreateReception")
	}

	mmCreateReception.mock.inspectFuncCreateReception = f

	return mmCreateReception
}

// Return sets up results that will be returned by ReceptionService.CreateReception
func (mmCreateReception *mReceptionServiceMockCreateReception) Return(rp1 *reception.Reception, err error) *ReceptionServiceMock {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Set")
	}

	if mmCreateReception.defaultExpectation == nil {
		mmCreateReception.defaultExpectation = &ReceptionServiceMockCreateReceptionExpectation{mock: mmCreateReception.mock}
	}
	mmCreateReception.defaultExpectation.results = &ReceptionServiceMockCreateReceptionResults{rp1, err}
	mmCreateReception.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateReception.mock
}

// Set uses given function f to mock the ReceptionService.CreateReception method
func (mmCreateReception *mReceptionServiceMockCreateReception) Set(f func(ctx context.Context, r *reception.Reception) (rp1 *reception.Reception, err error)) *ReceptionServiceMock {
	if mmCreateReception.defaultExpectation != nil {
		mmCreateReception.mock.t.Fatalf("Default expectation is already set for the ReceptionService.CreateReception method")
	}

	if len(mmCreateReception.expectations) > 0 {
		mmCreateReception.mock.t.Fatalf("Some expectations are already set for the ReceptionService.CreateReception method")
	}

	mmCreateReception.mock.funcCreateReception = f
	mmCreateReception.mock.funcCreateReceptionOrigin = minimock.CallerInfo(1)
	return mmCreateReception.mock
}

// When sets expectation for the ReceptionService.CreateReception which will trigger the result defined by the following
// Then helper
func (mmCreateReception *mReceptionServiceMockCreateReception) When(ctx context.Context, r *reception.Reception) *ReceptionServiceMockCreateReceptionExpectation {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("ReceptionServiceMock.CreateReception mock is already set by Set")
	}

	expectation := &ReceptionServiceMockCreateReceptionExpectation{
		mock:               mmCreateReception.mock,
		params:             &ReceptionServiceMockCreateReceptionParams{ctx, r},
		expectationOrigins: ReceptionServiceMockCreateReceptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateReception.expectations = append(mmCreateReception.expectations, expectation)
	return expectation
}

// Then sets up ReceptionService.CreateReception return parameters for the expectation previously defined by the When method
func (e *ReceptionServiceMockCreateReceptionExpectation) Then(rp1 *reception.Reception, err error) *ReceptionServiceMock {
	e.results = &ReceptionServiceMockCreateReceptionResults{rp1, err}
	return e.mock
}

// Times sets number of times ReceptionService.CreateReception should be invoked
func (mmCreateReception *mReceptionServiceMockCreateReception) Times(n uint64) *mReceptionServiceMockCreateReception {
	if n == 0 {
		mmCreateReception.mock.t.Fatalf("Times of ReceptionServiceMock.CreateReception mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateReception.expectedInvocations, n)
	mmCreateReception.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateReception
}

func (mmCreateReception *mReceptionServiceMockCreateReception) invocationsDone() bool {
	if len(mmCreateReception.expectations) == 0 && mmCreateReception.defaultExpectation == nil && mmCreateReception.mock.funcCreateReception == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateReception.mock.afterCreateReceptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateReception.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateReception implements mm_service.ReceptionService
func (mmCreateReception *ReceptionServiceMock) CreateReception(ctx context.Context, r *reception.Reception) (rp1 *reception.Reception, err error) {
	mm_atomic.AddUint64(&mmCreateReception.beforeCreateReceptionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateReception.afterCreateReceptionCounter, 1)

	mmCreateReception.t.Helper()

	if mmCreateReception.inspectFuncCreateReception != nil {
		mmCreateReception.inspectFuncCreateReception(ctx, r)
	}

	mm_params := ReceptionServiceMockCreateReceptionParams{ctx, r}

	// Record call args
	mmCreateReception.CreateReceptionMock.mutex.Lock()
	mmCreateReception.CreateReceptionMock.callArgs = append(mmCreateReception.CreateReceptionMock.callArgs, &mm_params)
	mmCreateReception.CreateReceptionMock.mutex.Unlock()

	for _, e := range mmCreateReception.CreateReceptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmCreateReception.CreateReceptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateReception.CreateReceptionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateReception.CreateReceptionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateReception.CreateReceptionMock.defaultExpectation.paramPtrs

		mm_got := ReceptionServiceMockCreateReceptionParams{ctx, r}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateReception.t.Errorf("ReceptionServiceMock.CreateReception got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReception.CreateReceptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.r != nil && !minimock.Equal(*mm_want_ptrs.r, mm_got.r) {
				mmCreateReception.t.Errorf("ReceptionServiceMock.CreateReception got unexpected parameter r, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReception.CreateReceptionMock.defaultExpectation.expectationOrigins.originR, *mm_want_ptrs.r, mm_got.r, minimock.Diff(*mm_want_ptrs.r, mm_got.r))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateReception.t.Errorf("ReceptionServiceMock.CreateReception got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateReception.CreateReceptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateReception.CreateReceptionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateReception.t.Fatal("No results are set for the ReceptionServiceMock.CreateReception")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmCreateReception.funcCreateReception != nil {
		return mmCreateReception.funcCreateReception(ctx, r)
	}
	mmCreateReception.t.Fatalf("Unexpected call to ReceptionServiceMock.CreateReception. %v %v", ctx, r)
	return
}

// CreateReceptionAfterCounter returns a count of finished ReceptionServiceMock.CreateReception invocations
func (mmCreateReception *ReceptionServiceMock) CreateReceptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReception.afterCreateReceptionCounter)
}

// CreateReceptionBeforeCounter returns a count of ReceptionServiceMock.CreateReception invocations
func (mmCreateReception *ReceptionServiceMock) CreateReceptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReception.beforeCreateReceptionCounter)
}

// Calls returns a list of arguments used in each call to ReceptionServiceMock.CreateReception.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateReception *mReceptionServiceMockCreateReception) Calls() []*ReceptionServiceMockCreateReceptionParams {
	mmCreateReception.mutex.RLock()

	argCopy := make([]*ReceptionServiceMockCreateReceptionParams, len(mmCreateReception.callArgs))
	copy(argCopy, mmCreateReception.callArgs)

	mmCreateReception.mutex.RUnlock()

	return argCopy
}

// MinimockCreateReceptionDone returns true if the count of the CreateReception invocations corresponds
// the number of defined expectations
func (m *ReceptionServiceMock) MinimockCreateReceptionDone() bool {
	if m.CreateReceptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateReceptionMock.invocationsDone()
}

// MinimockCreateReceptionInspect logs each unmet expectation
func (m *ReceptionServiceMock) MinimockCreateReceptionInspect() {
	for _, e := range m.CreateReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReceptionServiceMock.CreateReception at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateReceptionCounter := mm_atomic.LoadUint64(&m.afterCreateReceptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReceptionMock.defaultExpectation != nil && afterCreateReceptionCounter < 1 {
		if m.CreateReceptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReceptionServiceMock.CreateReception at\n%s", m.CreateReceptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReceptionServiceMock.CreateReception at\n%s with params: %#v", m.CreateReceptionMock.defaultExpectation.expectationOrigins.origin, *m.CreateReceptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReception != nil && afterCreateReceptionCounter < 1 {
		m.t.Errorf("Expected call to ReceptionServiceMock.CreateReception at\n%s", m.funcCreateReceptionOrigin)
	}

	if !m.CreateReceptionMock.invocationsDone() && afterCreateReceptionCounter > 0 {
		m.t.Errorf("Expected %d calls to ReceptionServiceMock.CreateReception at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateReceptionMock.expectedInvocations), m.CreateReceptionMock.expectedInvocationsOrigin, afterCreateReceptionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReceptionServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCloseReceptionInspect()

			m.MinimockCreateReceptionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReceptionServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ReceptionServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseReceptionDone() &&
		m.MinimockCreateReceptionDone()
}
