// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/KulaginNikita/pvz-service/internal/service.ProductService -o product_service_mock.go -n ProductServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/KulaginNikita/pvz-service/internal/domain/product"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// ProductServiceMock implements mm_service.ProductService
type ProductServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateProduct          func(ctx context.Context, p *product.Product) (err error)
	funcCreateProductOrigin    string
	inspectFuncCreateProduct   func(ctx context.Context, p *product.Product)
	afterCreateProductCounter  uint64
	beforeCreateProductCounter uint64
	CreateProductMock          mProductServiceMockCreateProduct

	funcDeleteProduct          func(ctx context.Context, pvzID uuid.UUID) (err error)
	funcDeleteProductOrigin    string
	inspectFuncDeleteProduct   func(ctx context.Context, pvzID uuid.UUID)
	afterDeleteProductCounter  uint64
	beforeDeleteProductCounter uint64
	DeleteProductMock          mProductServiceMockDeleteProduct
}

// NewProductServiceMock returns a mock for mm_service.ProductService
func NewProductServiceMock(t minimock.Tester) *ProductServiceMock {
	m := &ProductServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateProductMock = mProductServiceMockCreateProduct{mock: m}
	m.CreateProductMock.callArgs = []*ProductServiceMockCreateProductParams{}

	m.DeleteProductMock = mProductServiceMockDeleteProduct{mock: m}
	m.DeleteProductMock.callArgs = []*ProductServiceMockDeleteProductParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mProductServiceMockCreateProduct struct {
	optional           bool
	mock               *ProductServiceMock
	defaultExpectation *ProductServiceMockCreateProductExpectation
	expectations       []*ProductServiceMockCreateProductExpectation

	callArgs []*ProductServiceMockCreateProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProductServiceMockCreateProductExpectation specifies expectation struct of the ProductService.CreateProduct
type ProductServiceMockCreateProductExpectation struct {
	mock               *ProductServiceMock
	params             *ProductServiceMockCreateProductParams
	paramPtrs          *ProductServiceMockCreateProductParamPtrs
	expectationOrigins ProductServiceMockCreateProductExpectationOrigins
	results            *ProductServiceMockCreateProductResults
	returnOrigin       string
	Counter            uint64
}

// ProductServiceMockCreateProductParams contains parameters of the ProductService.CreateProduct
type ProductServiceMockCreateProductParams struct {
	ctx context.Context
	p   *product.Product
}

// ProductServiceMockCreateProductParamPtrs contains pointers to parameters of the ProductService.CreateProduct
type ProductServiceMockCreateProductParamPtrs struct {
	ctx *context.Context
	p   **product.Product
}

// ProductServiceMockCreateProductResults contains results of the ProductService.CreateProduct
type ProductServiceMockCreateProductResults struct {
	err error
}

// ProductServiceMockCreateProductOrigins contains origins of expectations of the ProductService.CreateProduct
type ProductServiceMockCreateProductExpectationOrigins struct {
	origin    string
	originCtx string
	originP   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateProduct *mProductServiceMockCreateProduct) Optional() *mProductServiceMockCreateProduct {
	mmCreateProduct.optional = true
	return mmCreateProduct
}

// Expect sets up expected params for ProductService.CreateProduct
func (mmCreateProduct *mProductServiceMockCreateProduct) Expect(ctx context.Context, p *product.Product) *mProductServiceMockCreateProduct {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("ProductServiceMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &ProductServiceMockCreateProductExpectation{}
	}

	if mmCreateProduct.defaultExpectation.paramPtrs != nil {
		mmCreateProduct.mock.t.Fatalf("ProductServiceMock.CreateProduct mock is already set by ExpectParams functions")
	}

	mmCreateProduct.defaultExpectation.params = &ProductServiceMockCreateProductParams{ctx, p}
	mmCreateProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateProduct.expectations {
		if minimock.Equal(e.params, mmCreateProduct.defaultExpectation.params) {
			mmCreateProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateProduct.defaultExpectation.params)
		}
	}

	return mmCreateProduct
}

// ExpectCtxParam1 sets up expected param ctx for ProductService.CreateProduct
func (mmCreateProduct *mProductServiceMockCreateProduct) ExpectCtxParam1(ctx context.Context) *mProductServiceMockCreateProduct {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("ProductServiceMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &ProductServiceMockCreateProductExpectation{}
	}

	if mmCreateProduct.defaultExpectation.params != nil {
		mmCreateProduct.mock.t.Fatalf("ProductServiceMock.CreateProduct mock is already set by Expect")
	}

	if mmCreateProduct.defaultExpectation.paramPtrs == nil {
		mmCreateProduct.defaultExpectation.paramPtrs = &ProductServiceMockCreateProductParamPtrs{}
	}
	mmCreateProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateProduct
}

// ExpectPParam2 sets up expected param p for ProductService.CreateProduct
func (mmCreateProduct *mProductServiceMockCreateProduct) ExpectPParam2(p *product.Product) *mProductServiceMockCreateProduct {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("ProductServiceMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &ProductServiceMockCreateProductExpectation{}
	}

	if mmCreateProduct.defaultExpectation.params != nil {
		mmCreateProduct.mock.t.Fatalf("ProductServiceMock.CreateProduct mock is already set by Expect")
	}

	if mmCreateProduct.defaultExpectation.paramPtrs == nil {
		mmCreateProduct.defaultExpectation.paramPtrs = &ProductServiceMockCreateProductParamPtrs{}
	}
	mmCreateProduct.defaultExpectation.paramPtrs.p = &p
	mmCreateProduct.defaultExpectation.expectationOrigins.originP = minimock.CallerInfo(1)

	return mmCreateProduct
}

// Inspect accepts an inspector function that has same arguments as the ProductService.CreateProduct
func (mmCreateProduct *mProductServiceMockCreateProduct) Inspect(f func(ctx context.Context, p *product.Product)) *mProductServiceMockCreateProduct {
	if mmCreateProduct.mock.inspectFuncCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("Inspect function is already set for ProductServiceMock.CreateProduct")
	}

	mmCreateProduct.mock.inspectFuncCreateProduct = f

	return mmCreateProduct
}

// Return sets up results that will be returned by ProductService.CreateProduct
func (mmCreateProduct *mProductServiceMockCreateProduct) Return(err error) *ProductServiceMock {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("ProductServiceMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &ProductServiceMockCreateProductExpectation{mock: mmCreateProduct.mock}
	}
	mmCreateProduct.defaultExpectation.results = &ProductServiceMockCreateProductResults{err}
	mmCreateProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateProduct.mock
}

// Set uses given function f to mock the ProductService.CreateProduct method
func (mmCreateProduct *mProductServiceMockCreateProduct) Set(f func(ctx context.Context, p *product.Product) (err error)) *ProductServiceMock {
	if mmCreateProduct.defaultExpectation != nil {
		mmCreateProduct.mock.t.Fatalf("Default expectation is already set for the ProductService.CreateProduct method")
	}

	if len(mmCreateProduct.expectations) > 0 {
		mmCreateProduct.mock.t.Fatalf("Some expectations are already set for the ProductService.CreateProduct method")
	}

	mmCreateProduct.mock.funcCreateProduct = f
	mmCreateProduct.mock.funcCreateProductOrigin = minimock.CallerInfo(1)
	return mmCreateProduct.mock
}

// When sets expectation for the ProductService.CreateProduct which will trigger the result defined by the following
// Then helper
func (mmCreateProduct *mProductServiceMockCreateProduct) When(ctx context.Context, p *product.Product) *ProductServiceMockCreateProductExpectation {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("ProductServiceMock.CreateProduct mock is already set by Set")
	}

	expectation := &ProductServiceMockCreateProductExpectation{
		mock:               mmCreateProduct.mock,
		params:             &ProductServiceMockCreateProductParams{ctx, p},
		expectationOrigins: ProductServiceMockCreateProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateProduct.expectations = append(mmCreateProduct.expectations, expectation)
	return expectation
}

// Then sets up ProductService.CreateProduct return parameters for the expectation previously defined by the When method
func (e *ProductServiceMockCreateProductExpectation) Then(err error) *ProductServiceMock {
	e.results = &ProductServiceMockCreateProductResults{err}
	return e.mock
}

// Times sets number of times ProductService.CreateProduct should be invoked
func (mmCreateProduct *mProductServiceMockCreateProduct) Times(n uint64) *mProductServiceMockCreateProduct {
	if n == 0 {
		mmCreateProduct.mock.t.Fatalf("Times of ProductServiceMock.CreateProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateProduct.expectedInvocations, n)
	mmCreateProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateProduct
}

func (mmCreateProduct *mProductServiceMockCreateProduct) invocationsDone() bool {
	if len(mmCreateProduct.expectations) == 0 && mmCreateProduct.defaultExpectation == nil && mmCreateProduct.mock.funcCreateProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateProduct.mock.afterCreateProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateProduct implements mm_service.ProductService
func (mmCreateProduct *ProductServiceMock) CreateProduct(ctx context.Context, p *product.Product) (err error) {
	mm_atomic.AddUint64(&mmCreateProduct.beforeCreateProductCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateProduct.afterCreateProductCounter, 1)

	mmCreateProduct.t.Helper()

	if mmCreateProduct.inspectFuncCreateProduct != nil {
		mmCreateProduct.inspectFuncCreateProduct(ctx, p)
	}

	mm_params := ProductServiceMockCreateProductParams{ctx, p}

	// Record call args
	mmCreateProduct.CreateProductMock.mutex.Lock()
	mmCreateProduct.CreateProductMock.callArgs = append(mmCreateProduct.CreateProductMock.callArgs, &mm_params)
	mmCreateProduct.CreateProductMock.mutex.Unlock()

	for _, e := range mmCreateProduct.CreateProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateProduct.CreateProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateProduct.CreateProductMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateProduct.CreateProductMock.defaultExpectation.params
		mm_want_ptrs := mmCreateProduct.CreateProductMock.defaultExpectation.paramPtrs

		mm_got := ProductServiceMockCreateProductParams{ctx, p}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateProduct.t.Errorf("ProductServiceMock.CreateProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProduct.CreateProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.p != nil && !minimock.Equal(*mm_want_ptrs.p, mm_got.p) {
				mmCreateProduct.t.Errorf("ProductServiceMock.CreateProduct got unexpected parameter p, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProduct.CreateProductMock.defaultExpectation.expectationOrigins.originP, *mm_want_ptrs.p, mm_got.p, minimock.Diff(*mm_want_ptrs.p, mm_got.p))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateProduct.t.Errorf("ProductServiceMock.CreateProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateProduct.CreateProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateProduct.CreateProductMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateProduct.t.Fatal("No results are set for the ProductServiceMock.CreateProduct")
		}
		return (*mm_results).err
	}
	if mmCreateProduct.funcCreateProduct != nil {
		return mmCreateProduct.funcCreateProduct(ctx, p)
	}
	mmCreateProduct.t.Fatalf("Unexpected call to ProductServiceMock.CreateProduct. %v %v", ctx, p)
	return
}

// CreateProductAfterCounter returns a count of finished ProductServiceMock.CreateProduct invocations
func (mmCreateProduct *ProductServiceMock) CreateProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProduct.afterCreateProductCounter)
}

// CreateProductBeforeCounter returns a count of ProductServiceMock.CreateProduct invocations
func (mmCreateProduct *ProductServiceMock) CreateProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProduct.beforeCreateProductCounter)
}

// Calls returns a list of arguments used in each call to ProductServiceMock.CreateProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateProduct *mProductServiceMockCreateProduct) Calls() []*ProductServiceMockCreateProductParams {
	mmCreateProduct.mutex.RLock()

	argCopy := make([]*ProductServiceMockCreateProductParams, len(mmCreateProduct.callArgs))
	copy(argCopy, mmCreateProduct.callArgs)

	mmCreateProduct.mutex.RUnlock()

	return argCopy
}

// MinimockCreateProductDone returns true if the count of the CreateProduct invocations corresponds
// the number of defined expectations
func (m *ProductServiceMock) MinimockCreateProductDone() bool {
	if m.CreateProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateProductMock.invocationsDone()
}

// MinimockCreateProductInspect logs each unmet expectation
func (m *ProductServiceMock) MinimockCreateProductInspect() {
	for _, e := range m.CreateProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductServiceMock.CreateProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateProductCounter := mm_atomic.LoadUint64(&m.afterCreateProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateProductMock.defaultExpectation != nil && afterCreateProductCounter < 1 {
		if m.CreateProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProductServiceMock.CreateProduct at\n%s", m.CreateProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProductServiceMock.CreateProduct at\n%s with params: %#v", m.CreateProductMock.defaultExpectation.expectationOrigins.origin, *m.CreateProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateProduct != nil && afterCreateProductCounter < 1 {
		m.t.Errorf("Expected call to ProductServiceMock.CreateProduct at\n%s", m.funcCreateProductOrigin)
	}

	if !m.CreateProductMock.invocationsDone() && afterCreateProductCounter > 0 {
		m.t.Errorf("Expected %d calls to ProductServiceMock.CreateProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateProductMock.expectedInvocations), m.CreateProductMock.expectedInvocationsOrigin, afterCreateProductCounter)
	}
}

type mProductServiceMockDeleteProduct struct {
	optional           bool
	mock               *ProductServiceMock
	defaultExpectation *ProductServiceMockDeleteProductExpectation
	expectations       []*ProductServiceMockDeleteProductExpectation

	callArgs []*ProductServiceMockDeleteProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ProductServiceMockDeleteProductExpectation specifies expectation struct of the ProductService.DeleteProduct
type ProductServiceMockDeleteProductExpectation struct {
	mock               *ProductServiceMock
	params             *ProductServiceMockDeleteProductParams
	paramPtrs          *ProductServiceMockDeleteProductParamPtrs
	expectationOrigins ProductServiceMockDeleteProductExpectationOrigins
	results            *ProductServiceMockDeleteProductResults
	returnOrigin       string
	Counter            uint64
}

// ProductServiceMockDeleteProductParams contains parameters of the ProductService.DeleteProduct
type ProductServiceMockDeleteProductParams struct {
	ctx   context.Context
	pvzID uuid.UUID
}

// ProductServiceMockDeleteProductParamPtrs contains pointers to parameters of the ProductService.DeleteProduct
type ProductServiceMockDeleteProductParamPtrs struct {
	ctx   *context.Context
	pvzID *uuid.UUID
}

// ProductServiceMockDeleteProductResults contains results of the ProductService.DeleteProduct
type ProductServiceMockDeleteProductResults struct {
	err error
}

// ProductServiceMockDeleteProductOrigins contains origins of expectations of the ProductService.DeleteProduct
type ProductServiceMockDeleteProductExpectationOrigins struct {
	origin      string
	originCtx   string
	originPvzID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteProduct *mProductServiceMockDeleteProduct) Optional() *mProductServiceMockDeleteProduct {
	mmDeleteProduct.optional = true
	return mmDeleteProduct
}

// Expect sets up expected params for ProductService.DeleteProduct
func (mmDeleteProduct *mProductServiceMockDeleteProduct) Expect(ctx context.Context, pvzID uuid.UUID) *mProductServiceMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("ProductServiceMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &ProductServiceMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs != nil {
		mmDeleteProduct.mock.t.Fatalf("ProductServiceMock.DeleteProduct mock is already set by ExpectParams functions")
	}

	mmDeleteProduct.defaultExpectation.params = &ProductServiceMockDeleteProductParams{ctx, pvzID}
	mmDeleteProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteProduct.expectations {
		if minimock.Equal(e.params, mmDeleteProduct.defaultExpectation.params) {
			mmDeleteProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteProduct.defaultExpectation.params)
		}
	}

	return mmDeleteProduct
}

// ExpectCtxParam1 sets up expected param ctx for ProductService.DeleteProduct
func (mmDeleteProduct *mProductServiceMockDeleteProduct) ExpectCtxParam1(ctx context.Context) *mProductServiceMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("ProductServiceMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &ProductServiceMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.params != nil {
		mmDeleteProduct.mock.t.Fatalf("ProductServiceMock.DeleteProduct mock is already set by Expect")
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteProduct.defaultExpectation.paramPtrs = &ProductServiceMockDeleteProductParamPtrs{}
	}
	mmDeleteProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteProduct
}

// ExpectPvzIDParam2 sets up expected param pvzID for ProductService.DeleteProduct
func (mmDeleteProduct *mProductServiceMockDeleteProduct) ExpectPvzIDParam2(pvzID uuid.UUID) *mProductServiceMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("ProductServiceMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &ProductServiceMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.params != nil {
		mmDeleteProduct.mock.t.Fatalf("ProductServiceMock.DeleteProduct mock is already set by Expect")
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteProduct.defaultExpectation.paramPtrs = &ProductServiceMockDeleteProductParamPtrs{}
	}
	mmDeleteProduct.defaultExpectation.paramPtrs.pvzID = &pvzID
	mmDeleteProduct.defaultExpectation.expectationOrigins.originPvzID = minimock.CallerInfo(1)

	return mmDeleteProduct
}

// Inspect accepts an inspector function that has same arguments as the ProductService.DeleteProduct
func (mmDeleteProduct *mProductServiceMockDeleteProduct) Inspect(f func(ctx context.Context, pvzID uuid.UUID)) *mProductServiceMockDeleteProduct {
	if mmDeleteProduct.mock.inspectFuncDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("Inspect function is already set for ProductServiceMock.DeleteProduct")
	}

	mmDeleteProduct.mock.inspectFuncDeleteProduct = f

	return mmDeleteProduct
}

// Return sets up results that will be returned by ProductService.DeleteProduct
func (mmDeleteProduct *mProductServiceMockDeleteProduct) Return(err error) *ProductServiceMock {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("ProductServiceMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &ProductServiceMockDeleteProductExpectation{mock: mmDeleteProduct.mock}
	}
	mmDeleteProduct.defaultExpectation.results = &ProductServiceMockDeleteProductResults{err}
	mmDeleteProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteProduct.mock
}

// Set uses given function f to mock the ProductService.DeleteProduct method
func (mmDeleteProduct *mProductServiceMockDeleteProduct) Set(f func(ctx context.Context, pvzID uuid.UUID) (err error)) *ProductServiceMock {
	if mmDeleteProduct.defaultExpectation != nil {
		mmDeleteProduct.mock.t.Fatalf("Default expectation is already set for the ProductService.DeleteProduct method")
	}

	if len(mmDeleteProduct.expectations) > 0 {
		mmDeleteProduct.mock.t.Fatalf("Some expectations are already set for the ProductService.DeleteProduct method")
	}

	mmDeleteProduct.mock.funcDeleteProduct = f
	mmDeleteProduct.mock.funcDeleteProductOrigin = minimock.CallerInfo(1)
	return mmDeleteProduct.mock
}

// When sets expectation for the ProductService.DeleteProduct which will trigger the result defined by the following
// Then helper
func (mmDeleteProduct *mProductServiceMockDeleteProduct) When(ctx context.Context, pvzID uuid.UUID) *ProductServiceMockDeleteProductExpectation {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("ProductServiceMock.DeleteProduct mock is already set by Set")
	}

	expectation := &ProductServiceMockDeleteProductExpectation{
		mock:               mmDeleteProduct.mock,
		params:             &ProductServiceMockDeleteProductParams{ctx, pvzID},
		expectationOrigins: ProductServiceMockDeleteProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteProduct.expectations = append(mmDeleteProduct.expectations, expectation)
	return expectation
}

// Then sets up ProductService.DeleteProduct return parameters for the expectation previously defined by the When method
func (e *ProductServiceMockDeleteProductExpectation) Then(err error) *ProductServiceMock {
	e.results = &ProductServiceMockDeleteProductResults{err}
	return e.mock
}

// Times sets number of times ProductService.DeleteProduct should be invoked
func (mmDeleteProduct *mProductServiceMockDeleteProduct) Times(n uint64) *mProductServiceMockDeleteProduct {
	if n == 0 {
		mmDeleteProduct.mock.t.Fatalf("Times of ProductServiceMock.DeleteProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteProduct.expectedInvocations, n)
	mmDeleteProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteProduct
}

func (mmDeleteProduct *mProductServiceMockDeleteProduct) invocationsDone() bool {
	if len(mmDeleteProduct.expectations) == 0 && mmDeleteProduct.defaultExpectation == nil && mmDeleteProduct.mock.funcDeleteProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteProduct.mock.afterDeleteProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteProduct implements mm_service.ProductService
func (mmDeleteProduct *ProductServiceMock) DeleteProduct(ctx context.Context, pvzID uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteProduct.beforeDeleteProductCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteProduct.afterDeleteProductCounter, 1)

	mmDeleteProduct.t.Helper()

	if mmDeleteProduct.inspectFuncDeleteProduct != nil {
		mmDeleteProduct.inspectFuncDeleteProduct(ctx, pvzID)
	}

	mm_params := ProductServiceMockDeleteProductParams{ctx, pvzID}

	// Record call args
	mmDeleteProduct.DeleteProductMock.mutex.Lock()
	mmDeleteProduct.DeleteProductMock.callArgs = append(mmDeleteProduct.DeleteProductMock.callArgs, &mm_params)
	mmDeleteProduct.DeleteProductMock.mutex.Unlock()

	for _, e := range mmDeleteProduct.DeleteProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteProduct.DeleteProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteProduct.DeleteProductMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteProduct.DeleteProductMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteProduct.DeleteProductMock.defaultExpectation.paramPtrs

		mm_got := ProductServiceMockDeleteProductParams{ctx, pvzID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteProduct.t.Errorf("ProductServiceMock.DeleteProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvzID != nil && !minimock.Equal(*mm_want_ptrs.pvzID, mm_got.pvzID) {
				mmDeleteProduct.t.Errorf("ProductServiceMock.DeleteProduct got unexpected parameter pvzID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.originPvzID, *mm_want_ptrs.pvzID, mm_got.pvzID, minimock.Diff(*mm_want_ptrs.pvzID, mm_got.pvzID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteProduct.t.Errorf("ProductServiceMock.DeleteProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteProduct.DeleteProductMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteProduct.t.Fatal("No results are set for the ProductServiceMock.DeleteProduct")
		}
		return (*mm_results).err
	}
	if mmDeleteProduct.funcDeleteProduct != nil {
		return mmDeleteProduct.funcDeleteProduct(ctx, pvzID)
	}
	mmDeleteProduct.t.Fatalf("Unexpected call to ProductServiceMock.DeleteProduct. %v %v", ctx, pvzID)
	return
}

// DeleteProductAfterCounter returns a count of finished ProductServiceMock.DeleteProduct invocations
func (mmDeleteProduct *ProductServiceMock) DeleteProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProduct.afterDeleteProductCounter)
}

// DeleteProductBeforeCounter returns a count of ProductServiceMock.DeleteProduct invocations
func (mmDeleteProduct *ProductServiceMock) DeleteProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProduct.beforeDeleteProductCounter)
}

// Calls returns a list of arguments used in each call to ProductServiceMock.DeleteProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteProduct *mProductServiceMockDeleteProduct) Calls() []*ProductServiceMockDeleteProductParams {
	mmDeleteProduct.mutex.RLock()

	argCopy := make([]*ProductServiceMockDeleteProductParams, len(mmDeleteProduct.callArgs))
	copy(argCopy, mmDeleteProduct.callArgs)

	mmDeleteProduct.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteProductDone returns true if the count of the DeleteProduct invocations corresponds
// the number of defined expectations
func (m *ProductServiceMock) MinimockDeleteProductDone() bool {
	if m.DeleteProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteProductMock.invocationsDone()
}

// MinimockDeleteProductInspect logs each unmet expectation
func (m *ProductServiceMock) MinimockDeleteProductInspect() {
	for _, e := range m.DeleteProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductServiceMock.DeleteProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteProductCounter := mm_atomic.LoadUint64(&m.afterDeleteProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteProductMock.defaultExpectation != nil && afterDeleteProductCounter < 1 {
		if m.DeleteProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ProductServiceMock.DeleteProduct at\n%s", m.DeleteProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ProductServiceMock.DeleteProduct at\n%s with params: %#v", m.DeleteProductMock.defaultExpectation.expectationOrigins.origin, *m.DeleteProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteProduct != nil && afterDeleteProductCounter < 1 {
		m.t.Errorf("Expected call to ProductServiceMock.DeleteProduct at\n%s", m.funcDeleteProductOrigin)
	}

	if !m.DeleteProductMock.invocationsDone() && afterDeleteProductCounter > 0 {
		m.t.Errorf("Expected %d calls to ProductServiceMock.DeleteProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteProductMock.expectedInvocations), m.DeleteProductMock.expectedInvocationsOrigin, afterDeleteProductCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProductServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateProductInspect()

			m.MinimockDeleteProductInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProductServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProductServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateProductDone() &&
		m.MinimockDeleteProductDone()
}
